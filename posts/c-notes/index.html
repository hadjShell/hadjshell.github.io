<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C Notes | Hadjshell</title><meta name=keywords content="刀法,C"><meta name=description content="C Notes Reference C语言程序设计 - 翁恺 Kernighan, B.W. & Ritchie, D.M. (1988) The C programming language. 2nd ed.. Englewood Cliffs, N.J.: Prentice Hall. 导论 计算机的思维方式：枚举
算法改进暴力枚举
程序的执行：
解释：借助一个程序，那个程序试图理解你的程序，然后按照你的要求执行
编译：借助一个程序，把你的程序翻译成机器语言，然后执行机器语言的程序
编译是将源程序翻译成可执行的目标代码，翻译与执行是分开的；而解释是对源程序的翻译与执行一次性完成，不生成可存储的目标代码。这只是表象，二者背后的最大区别是：对解释执行而言，程序运行时的控制权在解释器而不在用户程序；对编译执行而言，运行时的控制权在用户程序。
语言本身没有解释和编译之分，只是具体执行方式不同
现代两种执行方式已经没有过大的区别，各有优劣
现代编程语言语法上差异很小，几乎都是C-like语言
某些场景，例如操作系统，只能用C写
语言的能力/适用领域主要决定因素：
库 传统 FORTRAN -> BCPL -> B -> C
C implementations give a better understanding of how the machine behaves. There is no language runtime environment or virtual machine between you and the underlying machine."><meta name=author content><link rel=canonical href=https://hadjshell.github.io/posts/c-notes/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://hadjshell.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://hadjshell.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://hadjshell.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://hadjshell.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://hadjshell.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="C Notes"><meta property="og:description" content="C Notes Reference C语言程序设计 - 翁恺 Kernighan, B.W. & Ritchie, D.M. (1988) The C programming language. 2nd ed.. Englewood Cliffs, N.J.: Prentice Hall. 导论 计算机的思维方式：枚举
算法改进暴力枚举
程序的执行：
解释：借助一个程序，那个程序试图理解你的程序，然后按照你的要求执行
编译：借助一个程序，把你的程序翻译成机器语言，然后执行机器语言的程序
编译是将源程序翻译成可执行的目标代码，翻译与执行是分开的；而解释是对源程序的翻译与执行一次性完成，不生成可存储的目标代码。这只是表象，二者背后的最大区别是：对解释执行而言，程序运行时的控制权在解释器而不在用户程序；对编译执行而言，运行时的控制权在用户程序。
语言本身没有解释和编译之分，只是具体执行方式不同
现代两种执行方式已经没有过大的区别，各有优劣
现代编程语言语法上差异很小，几乎都是C-like语言
某些场景，例如操作系统，只能用C写
语言的能力/适用领域主要决定因素：
库 传统 FORTRAN -> BCPL -> B -> C
C implementations give a better understanding of how the machine behaves. There is no language runtime environment or virtual machine between you and the underlying machine."><meta property="og:type" content="article"><meta property="og:url" content="https://hadjshell.github.io/posts/c-notes/"><meta property="og:image" content="https://hadjshell.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-06T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-06T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hadjshell.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="C Notes"><meta name=twitter:description content="C Notes Reference C语言程序设计 - 翁恺 Kernighan, B.W. & Ritchie, D.M. (1988) The C programming language. 2nd ed.. Englewood Cliffs, N.J.: Prentice Hall. 导论 计算机的思维方式：枚举
算法改进暴力枚举
程序的执行：
解释：借助一个程序，那个程序试图理解你的程序，然后按照你的要求执行
编译：借助一个程序，把你的程序翻译成机器语言，然后执行机器语言的程序
编译是将源程序翻译成可执行的目标代码，翻译与执行是分开的；而解释是对源程序的翻译与执行一次性完成，不生成可存储的目标代码。这只是表象，二者背后的最大区别是：对解释执行而言，程序运行时的控制权在解释器而不在用户程序；对编译执行而言，运行时的控制权在用户程序。
语言本身没有解释和编译之分，只是具体执行方式不同
现代两种执行方式已经没有过大的区别，各有优劣
现代编程语言语法上差异很小，几乎都是C-like语言
某些场景，例如操作系统，只能用C写
语言的能力/适用领域主要决定因素：
库 传统 FORTRAN -> BCPL -> B -> C
C implementations give a better understanding of how the machine behaves. There is no language runtime environment or virtual machine between you and the underlying machine."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hadjshell.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C Notes","item":"https://hadjshell.github.io/posts/c-notes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C Notes","name":"C Notes","description":"C Notes Reference C语言程序设计 - 翁恺 Kernighan, B.W. \u0026amp; Ritchie, D.M. (1988) The C programming language. 2nd ed.. Englewood Cliffs, N.J.: Prentice Hall. 导论 计算机的思维方式：枚举\n算法改进暴力枚举\n程序的执行：\n解释：借助一个程序，那个程序试图理解你的程序，然后按照你的要求执行\n编译：借助一个程序，把你的程序翻译成机器语言，然后执行机器语言的程序\n编译是将源程序翻译成可执行的目标代码，翻译与执行是分开的；而解释是对源程序的翻译与执行一次性完成，不生成可存储的目标代码。这只是表象，二者背后的最大区别是：对解释执行而言，程序运行时的控制权在解释器而不在用户程序；对编译执行而言，运行时的控制权在用户程序。\n语言本身没有解释和编译之分，只是具体执行方式不同\n现代两种执行方式已经没有过大的区别，各有优劣\n现代编程语言语法上差异很小，几乎都是C-like语言\n某些场景，例如操作系统，只能用C写\n语言的能力/适用领域主要决定因素：\n库 传统 FORTRAN -\u0026gt; BCPL -\u0026gt; B -\u0026gt; C\nC implementations give a better understanding of how the machine behaves. There is no language runtime environment or virtual machine between you and the underlying machine.","keywords":["刀法","C"],"articleBody":"C Notes Reference C语言程序设计 - 翁恺 Kernighan, B.W. \u0026 Ritchie, D.M. (1988) The C programming language. 2nd ed.. Englewood Cliffs, N.J.: Prentice Hall. 导论 计算机的思维方式：枚举\n算法改进暴力枚举\n程序的执行：\n解释：借助一个程序，那个程序试图理解你的程序，然后按照你的要求执行\n编译：借助一个程序，把你的程序翻译成机器语言，然后执行机器语言的程序\n编译是将源程序翻译成可执行的目标代码，翻译与执行是分开的；而解释是对源程序的翻译与执行一次性完成，不生成可存储的目标代码。这只是表象，二者背后的最大区别是：对解释执行而言，程序运行时的控制权在解释器而不在用户程序；对编译执行而言，运行时的控制权在用户程序。\n语言本身没有解释和编译之分，只是具体执行方式不同\n现代两种执行方式已经没有过大的区别，各有优劣\n现代编程语言语法上差异很小，几乎都是C-like语言\n某些场景，例如操作系统，只能用C写\n语言的能力/适用领域主要决定因素：\n库 传统 FORTRAN -\u003e BCPL -\u003e B -\u003e C\nC implementations give a better understanding of how the machine behaves. There is no language runtime environment or virtual machine between you and the underlying machine.\n标准：ANSI C -\u003e C99\nC is a general-purpose programming language.\n指针是C的灵魂\nC的应用场景：\n操作系统，编译器 嵌入式系统 驱动程序 底层驱动 图形引擎、图像处理、声音效果 Ｃ是一种工业语言\n开发效率＞＞学习过程 开发效率＞＞开发乐趣 历史原因，Ｃ的编译器有很多，出现了“方言”现象\n变量和常量 变量是一个保存数据的地方，是一段存储空间的别名 变量定义： ; 标识符：字母，数字，下划线；第一个字符必须为字母或下划线；大小写敏感；不能用保留字 赋值：=右边的值赋给左边的变量 初始化：定义变量时赋值 没有初始化的变量，值为随机数 C语言类型严格 C99可以在任意位置定义变量；ANSI C只能在代码开头定义变量 字面量（literal）：直接写在程序里的数值（magic number） 常量定义：const = 常量好处：物理意义；便于Debug 数据类型 C语言的变量，必须：\n在使用前定义 确定类型 C以后的语言向两个方向发展：\nC++，Java更强调类型，对类型检查严格\nJavaScript，Python，PHP不看重类型，甚至不需要事先定义\n支持强类型的观点认为明确的类型有助于尽早发现程序中的简单错误\n反对强类型的观点认为多于强调类型迫使程序员面对底层实现而非事务逻辑\nC语言需要类型，但是对类型的安全检查并不够\n类型 关键字 整数 char, short, int, long, long long 浮点数 float, double, long double 逻辑 bool 指针 自定义类型 数据类型的区别：\n内存中占据的大小 内存中的表达形式：补码，编码 sizeof()：是一个运算符，给出某个类型或变量在内存中所占据的字节数\n静态运算符，结果在编译时刻就决定了 不要在sizeof的括号里做运算，这些运算是不会做的 字面量也有数据类型\n默认int, double, char, string 可以指定类型：加后缀 整型 类型 字节 char 1 short 2 int 取决于编译器（CPU） long 取决于编译器（CPU） long long 8 计算机内部表达：补码\n类型 范围 char -128 ~ 127 short -32768 ~ 32767 int -231 ~ 231 - 1 (-2147483648 ~ 2147483647) unsigned\n初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位 整数是以纯二进制方式进行运算的\n整数越界\n格式化输入输出 类型 %d char, short, int, long %u unsigned %ld long long %lu unsigned long long %o 8进制 %x 16进制 以0开始的数字字面量是8进制；以0x开始的数字字面量是16进制\n为什么有这么多整数类型？\n为了准确表达内存，做底层程序的需要 历史原因 没有特殊需要，选择int\n现在CPU字长普遍32位或64位，一次内存读写就是一个int，一次计算也是一个int，选择更短的类型不会更快，甚至可能更慢 现代编译器一般会设计内存对齐，所以更短的类型实际在内存中有可能也占据一个int的大小 unsigned与否只是输出的不同，内部计算是一样的 浮点类型 类型 字长 范围 有效数字 float 32 $\\pm(1.20 * 10^{-38} - 3.40 * 10^{38}), 0, \\pm inf, nan$ 7 double 64 $\\pm(2.20 * 10^{-308} - 1.79 * 10^{308}), 0, \\pm inf, nan$ 15 printf输出inf表示超过范围的浮点数，输出nan表示不存在的浮点数\nint main() { printf(\"%f\\n\", 12.0 / 0.0); printf(\"%f\\n\", -12.0 / 0.0); printf(\"%f\\n\", 0.0 / 0.0); return 0; } Output: inf -inf nan 类型 scanf printf float %f %f, %e double %lf %f, %e %e：科学计数法格式 字面量也可使用科学计数法格式，例：1e-10 输出精度，例：%.5f，四舍五入 浮点类型对数据的表示是不准确的，是近似的\n二进制能表示的数是有限的，但数是连续的 浮点运算没有精度\n不能直接比较 误差会累积 转而使用整型解决实际问题 int main() { float a, b, c; a = 1.345f; b = 1.123f; c = a + b; if(c == 2.468) printf(\"Equal!\\n\"); else printf(\"Not equal! c = %.10f, or %f\\n\", c, c); return 0; } // f1 == f2 可能失败 // fabs(f1 - f2) \u003c 1e-12 来比较 浮点数内部表达：编码\n浮点数在计算时是由专用的硬件部件实现的\n没有特殊需要，使用double\n字符类型 char既是整型，也是字符型 格式化输入输出：%c 字符字面量：''表示 ASCII码 转义字符-Escape character 用来表达无法打印出来的控制字符或特殊字符，由\\开头，后面跟上一个字符\n常用转义字符 意义 \\b 回退一格 \\t 到下一个表格位 \\n 换行 \\r 回车 \\\" 双引号 \\' 单引号 \\\\ 反斜杠本身 回退一般不代表删除 制表位：每行的固定位置，而不是固定大小的字符数量 换行实际上是回车和换行两个动作 类型转换 自动类型转换 当运算符两边出现不一致的类型时，会自动转换成较大的类型 char -\u003e short -\u003e int -\u003e long -\u003e long long int -\u003e float -\u003e double 对于printf，任何小于int的类型会被转换成int，float会被转换成double scanf不会 强制类型转换 (type) value 注意安全性 只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型 强制类型转换的优先级高于四则运算 逻辑类型 C语言原本是没有bool类型的 #include 之后可以使用true，false 实际上是整型，1和0 运算 表达式：一系列运算符和操作数的组合\n运算符（operator）\n运算类型 运算符 四则 + - * / % () 关系 \u003c \u003e \u003c= \u003e= == != 逻辑 \u0026\u0026 || ! 位 \u0026 | ^ » « ~ 单目 + - 赋值 = 复合赋值 += -= *= /= %= 递增递减 ++ – 条件 ? : 逗号 , 操作数（operand）\n四则 整型除法舍弃小数部分 浮点数不能取余 优先级：正负 \u003e 乘除 \u003e 取余 \u003e 加减 \u003e 赋值 赋值 赋值也是运算，也有结果 例：a = 6的结果是6 自右向左结合 递增递减 前缀：a++结果是a加1以前的值 后缀：++a结果是a加1以后的值 a + 1是附作用 关系 比较结果：逻辑值真1假0 优先级比算术低，比赋值高 连续的关系运算从左向右执行 逻辑 短路法则：逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算 逗号 逗号用来连接两个表达式，并以右边的表达式的值作为它的结果 逗号运算符的优先级是最低的 主要在for中使用 位运算 直接对二进制位进行操作 按位与常用于： 让某一位或某些位为0：和0与 取一个数中的一段：x \u0026 0x00ff0000 按位或常用于： 使得一位或一些位为1：和1或 把两个数拼起来：0x00ff | 0xff00 按位异或：相同为0，不同为1 某位取反：和1异或 某位不变：和0异或 左移 高位移出，低位补零 所有小于int的类型，移位以int的方式做，结果是int x \u003c\u003c= 1 == x *= 2 右移 低位移出，高位补符号位 x \u003e\u003e= 1 == x /= 2 流程控制 结构化的基石 块：{} 选择 If - else 二路分支 嵌套 级联 else总是和最近的if匹配 “单一出口”原则 Switch 多路分支 控制表达式只能是整数型 case常量可以是常数，也可以是常数计算的表达式 case判断代码块内执行的开始 合并分支 break语句，没有break会顺序向下执行 默认情况执行default下的语句 default不是必须但是最好有 循环 While 先判断条件再执行循环体 Do while 先执行一次循环体再判断条件 For 如果有固定次数，用for；如果必须执行一次，用do while；其他情况用while\n循环控制：break，continue；最近匹配原则，针对当前循环\nbreak对if-else不起作用\n循环嵌套\n跳出多重循环：goto\n给定条件的整数集：枚举 + 剔除\n函数 函数是可以重复利用的代码块，接受零个或多个参数，做一件事情，并返回零个或一个值\n函数本质是占用一片连续内存的代码\n函数定义\n函数头：返回类型 函数名 参数列表 函数体 函数调用：函数名(参数值);\n执行 -\u003e 调用函数 -\u003e 执行调用函数 -\u003e 返回 -\u003e 恢复执行 函数返回：return\nreturn停止函数的执行，并返回一个值 return;, return exp; void\nvoid不能用于定义变量 用于函数定义，表示无返回值或无参数 type func();表示接受任意多的参数 函数的先后关系\nC的编译器自上而下顺序分析 调用函数需要先声明或定义 声明定义要一致 参数传递\n值传递 调用函数时给的值与参数类型不匹配是C语言传统上最大的漏洞，编译器会隐式地进行类型转换 每个函数有自己的变量空间，参数也位于这个空间中 变量分类\n局部（本地）变量：函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数这次运行所独有的，称作局部变量 定义在函数内部的变量，参数 定义在语句块内的变量 只能在当前块中访问使用 块外定义变量在块内仍然有效 本地变量不会被默认初始化 参数在进入函数时会初始化 全局变量：定义在函数外面的变量 没有初始化的全局变量会得到0值 指针会得到null值 只能用编译时已知的值来初始化全局变量 全局变量初始化发生在main函数之前 工程中，全局变量通常以g作为前缀命名 同名变量 不同块中的局部变量可以同名 同一块中的局部变量不可以同名 块内同名变量覆盖块外同名变量 静态变量：static 静态本地变量 作用域：块内；生命期：程序生命期 静态本地变量只会在第一次进入函数时初始化一次 离开函数时，静态本地变量会继续存在并保持其值 特殊的全局变量，创建于全局数据区 静态全局变量 作用域：文件作用域；生命期：程序生命期 使用全局变量和静态本地变量的函数是线程不安全的 作用域：变量定义后的可访问范围\n局部变量：定义开始到代码块结束 全局变量：程序的任何地方 生命期：变量从创建到销毁的时间\n局部变量：进入作用域时创建，离开作用域时自动销毁 全局变量：程序开始运行时创建，程序结束时自动销毁 调用函数里的,不是运算符\nC语言不允许函数嵌套定义，可以放声明\nC语言程序的入口：main函数\nmain()是应用程序与操作系统的“约定” C语言可以定义参数可变的函数\n参数可变函数的实现依赖于stdarg.h va_list：参数集合 va_arg：取具体参数值 va_start：标识参数访问的开始 va_end：标识参数访问的结束 可变参数必须从头到尾按照顺序逐个访问 参数列表中至少要存在一个确定的命名参数 可变参数函数无法确定实际存在的参数的数量 可变参数函数无法确定参数的实际类型 #include #include float average(int n, ...) { va_list args; int i = 0; float sum = 0; va_start(args, n); for(i=0; i\u003cn; i++) { sum += va_arg(args, int); } va_end(args); return sum / n; } int main() { printf(\"%f\\n\", average(5, 1, 2, 3, 4, 5)); printf(\"%f\\n\", average(4, 1, 2, 3, 4)); return 0; } 函数设计原则\n函数从意义上应该是一个独立的功能模块 函数名要在一定程度上反映函数的功能 函数参数名要能够体现参数的意义 尽量避免在函数中使用全局变量 当函数参数不应该在函数体内部被修改时，应该加上const声明 如果参数是指针，且仅作输入参数，则应加上const声明 不能省略返回值的类型 对参数进行有效性检查，对指针参数的检查尤为重要 函数体的规模要小，尽量控制在80行代码之内 相同的输入对应相同的输出，避免有状态函数 避免函数有过多的参数，尽量控制在4个以内 太多可以考虑结构体 有时候函数不需要返回值，但为了增加灵活性，如支持链式表达，可以附加返回值 数组 数组是相同数据类型变量的有序集合 数组定义： identifier[size]; 数组类型：[size] 元素数量必须是整数，必须是编译时刻确定的字面量 C99之后可以使用变量 数组在计算机内是一片连续的内存 数组一旦创建，不能改变大小 数组访问：identifier[index] 数组下标从0开始 可以使用变量作为下标 编译器和运行环境都不会检查数组下标是否越界，无论读写 一旦程序运行，数组越界可能造成问题，导致程序崩溃 不同机器上无法复现程序的一大问题：没有考虑数组越界 长度为0数组可以定义，但是无用，自然越界 数组初始化 identifier[N] = {v0, v1, ..., vn-1}; 不初始化是随机值 自动确定数组大小： identifier[] = {v0, v1, ..., vn-1}; 部分初始化： identifier[N] = {[0] = 2, [2] = 3, 6, }; 用[n]在初始化数据中给出定位 没有定位的数据姐在前面的位置后面 其他位置补零 适合初始数据稀疏的数组 数组大小：sizeof(identifier) 数组个数：sizeof(identifier) / sizeof(identifier[0]) 数组变量本身不能被赋值。要想拷贝一个数组，只能遍历 数组作为函数参数时，往往必须再用另一个参数来传入数组的大小 数组变量本身表达地址，无需用\u0026取地址；数组单元表达的是变量 二维数组 identifier[M][N]; 通常理解为M行N列的矩阵，或者M个大小为N的一维数组 二维数组初始化列数必须给出，行数可以自动确定 检查行 检查列 检查对角线，反对角线 const数组 const identifier[] = {0, }; 表明每个数组单元都是const 必须通过初始化进行赋值 保护数组不被函数破坏 指针 \u0026运算符：获得变量的地址，他的操作数必须是变量\n格式化输出：%p 地址的大小与编译器有关 内存地址本质上是一个无符号整数 指针变量：保存地址的变量\n普通变量放的是值 禁止将普通数值当作地址赋值给指针变量，除非你知道自己在干什么 指针定义： *p;或者* p;\n决定访问内存时的长度范围\n个人理解，指针类型也是个数据类型\n访问指针地址上的变量：*p\n可以做右值也可以做左值 没有赋值前不要访问 指针应用场景\n交换变量 函数返回多个值，某些值就只能通过指针返回 传入的参数实际上是需要保存结果的变量的地址 函数返回运算的状态(0, 1)，结果通过指针返回 可能会出错的运算 后续语言（C++，Java）采用了异常机制来解决这个问题 指针与数组\n函数参数表中的数组实际上是指针，但是可以用数组的运算符[]进行计算，不再含有数组长度信息\nvoid func(int a[]);和void func(int* a);作为函数原型是等价的\n数组类型和指针类型不是等价的\n[]运算符可以对数组做，也可以对指针做\n*运算符可以对指针做，也可以对数组做\narray, \u0026array, \u0026array[0]区别\narray可以当作一个指针常量，指向数组第一个元素\n两种情况数组名不是用指针常量来表示 sizeof(array)：返回整个数组的长度，而不是指针的长度 \u0026array：返回一个指向数组的指针，而不是一个指向指针的指针 \u0026array是一个指针值，指向整个数组\n\u0026array[0]是一个指针值，指向数组的第一个元素\n三者值相同，但意义不同\n这是一个很好的解释\nint main() { int array[5] = {0}; int (*p)[5] = \u0026array;\t// pointer to whole array // ERROR // Because array is a const pointer // array = 5345454; printf(\" array = %p\\n\", array); printf(\" \u0026array = %p\\n\", \u0026array); printf(\" \u0026array[0] = %p\\n\", \u0026array[0]); printf(\" array + 1 = %p\\n\", array + 1); printf(\"\u0026array[0] + 1 = %p\\n\", \u0026array[0] + 1); printf(\" \u0026array + 1 = %p\\n\", \u0026array + 1); printf(\"\\n\"); printf(\" sizeof(array) = %d\\n\", sizeof(array)); printf(\"sizeof(\u0026array) = %d\\n\", sizeof(\u0026array)); printf(\"\\n\"); return 0; } Output: array = 0061FEEC \u0026array = 0061FEEC \u0026array[0] = 0061FEEC array + 1 = 0061FEF0 \u0026array[0] + 1 = 0061FEF0 \u0026array + 1 = 0061FF00 sizeof(array) = 20 sizeof(\u0026array) = 4 指针与const\n指针是const： * const p; 该指针变量一旦得到了地址值，不能再指向其他变量 指针所指的是const： const* p;，const * p; 表示不能通过这个指针去修改指向的变量，并不能使得那个变量成为const 总是可以把一个非const的值转换成const 当要传递的参数类型比地址大的时候，这是一种常用的手段：既能用较少的字节数传递值给参数，又能避免函数修改外面的变量 指针运算\n给指针加，减一个整数\n偏移量 p + n -\u003e (unsigned int) p + n * sizeof(*p) 如果指针不是指向一片连续分配的空间，如数组，则这种计算没有意义 递增递减\n两个指针相减\n结果也是偏移量 *p++\n取出p所指的数据，然后把p移到下一个位置去\n*的优先级低于++ --\n常用于数组类的连续空间操作\nchar array[] = {0, 1, 2, -1}; char* p = array; while(*p != -1) { printf(\"%d\", *p++); } 在某些CPU上，这可以直接被翻译成一条汇编指令\n比较\n0地址\n所有程序都有0地址，通常不能随意读写 NULL是一个预定义的符号，表示0地址 可以用0地址来表示特殊的事情 返回的指针是无效的 指针没有被真正初始化（先初始化为0） 指针的类型转换\nvoid*表示不知道指向什么的指针 不能访问数据 计算与char*相同（不相通） 往往用在底层程序中 (*) identifier; 并不改变指向变量的类型 动态内存分配\n#include \u003ctype\u003e* p = (\u003ctype\u003e*) malloc(n * sizeof(\u003ctype\u003e)); if(p != NULL) { // statement } free(p); p = NULL; // 动态分配内存的基本操作架构 C99可以直接用变量定义数组大小\nvoid* malloc(size_t size);\n申请的空间大小是以字节为单位的 需要自己将返回结果转换成自己需要的类型 申请失败返回0(NULL) free()\n把申请的来的空间还给系统 只能还申请来的空间的首地址 free(NULL)不会出错 指针与函数\n函数名就是函数体代码的起始地址\n通过函数名调用函数，本质为指定具体地址的跳转执行\n可以定义指针保存函数入口地址\n(*pFunc)(, ) = func;\n\u0026func和func数值相同，意义相同\n调用函数：pFunc(par);或*pFunc(par);\n不能进行指针运算\n应用：\n让程序跳转到固定地址执行，多用于嵌入式开发 回调函数（监听器模式的基础） 调用者不知道具体事件发生时需要的调用函数 被调函数不知道何时被调用，只知道需要完成的任务 当具体时间发生时，调用者通过函数指针调用具体函数 回调机制中调用者和被调函数互不依赖 #include typedef int(*Weapon)(int); void fight(Weapon wp, int arg) { int result = 0; printf(\"Fight boss!\\n\"); result = wp(arg); printf(\"Boss loss: %d\\n\", result); } int knife(int n) { int ret = 0; int i = 0; for(i=0; i\u003cn; i++) { printf(\"Knife attack: %d\\n\", 1); ret++; } return ret; } int sword(int n) { int ret = 0; int i = 0; for(i=0; i\u003cn; i++) { printf(\"Sword attack: %d\\n\", 5); ret += 5; } return ret; } int gun(int n) { int ret = 0; int i = 0; for(i=0; i\u003cn; i++) { printf(\"Gun attack: %d\\n\", 10); ret += 10; } return ret; } int main() { fight(knife, 3); fight(sword, 4); fight(gun, 5); return 0; } 返回指针的函数\n返回本地变量的地址是危险的 返回全局变量或静态本地变量的地址是安全的 返回在函数内malloc的内存是安全的，但是容易造成问题 最好的做法是返回传入的指针 数组参数退化\n数组参数 等效的指针参数 a[size] * a * a[size] ** a a[m][n] (*a)[n] 字符数组和字符串 字符数组：char word[] = {'H', 'E', 'L', 'L', 'O'}; 字符串 C语言实际上没有字符串概念，用字符数组模拟\nchar word[] = {'H', 'E', 'L', 'L', 'O', '\\0'};\n以0（整数0）结尾的一串字符\n0或\\0是一样的（字节大小不同，4：1），但是和'0'不同\n0表示字符串的结束，但它不是字符串的一部分，计算长度时不包含这个0\n字符串以数组形式存在，以数组或指针的形式访问，更多的是以指针的形式\nstring.h\n字符串常量（字面量）\n\"string\" 会被编译器变成一个字符数组放在全局只读代码段，数组长度是字符个数+1，结尾有表示结束的0 两个相邻的字符串常量会连接起来 可以当作常量指针 字符串变量\nchar* str = \"Hello\"; str是一个指针，初始化为指向一个字符串常量 因为字符串常量不能被修改，所以实际上str是const char*类型 历史原因，编译器接受不带const的写法 试图对str所指的字符串做写入会导致程序崩溃 char word[] = \"Hello\"; 定义为数组类型可以修改内部的字符串 实际上编译器隐式地将字符串常量拷贝到定义的数组空间 指针还是数组？ 构造字符串：数组 处理字符串：指针 char line[10] = \"Hello\"; 字符串赋值：char* str1 = \"hello\"; char* str2 = str1;\n并没有产生新的字符串，只是让str2指向了str1所指的字符串 字符串输入输出：%s\nscanf读入一个单词（到空格，tab或回车为止） scanf是不安全的，因为不知道要读入的内容的长度 %7s：安全的输入，数字表示最多允许读入的字符数量。如果输入的长度超过指定长度，下一次的scanf会在上一次读入的终点接着读 空字符串\n只有一个\\0的字符串 char buffer[100] = \"\"; 一个空字符串，buffer[0] == '\\0' char buffer[] = \"\"; 这个数组长度只有1 字符串数组\nchar** a\na是一个指针，指向另一个指针，那个指针指向一个字符（串） 也可以看成一个指针数组，前提访问合法 char a[][size]\n可以表示一个字符串数组，但是里面的字符串大小有限制 char* a[]\n也可以表示一个字符串数组，里面是一个个指向字符串的指针\n(*p1)[size]和* p2[size]的区别\n一个很好的解释\n一个是指向整个数组的指针，一个是数据元素是指针的数组\n*p1返回的是指向的数组的首地址\n*p2返回的是指针数组里第一个指针元素的值\n程序参数\nint main(int argc, char const *argv[]) argv[0]是命令本身，当使用Unix的符号链接时，反应符号链接的名字 putchar\nint putchar(int c); 向标准输出写一个字符 返回写了几个字符，EOF(-1)表示写失败 getchar\nint getchar(void); 从标准输入读入一个字符 返回读到的字符 返回EOF Windows：Ctrl + Z Unix：Ctrl + D shell进行行编辑，然后程序从缓冲区读入数据 字符串函数\nstrlen\nsize_t strlen(const char *s); 返回字符串的长度 strcmp\nint strcmp(const char *s1, const char *s2); 比较两个字符串，返回： 0：s1 == s2 s1[idx] - s2[idx]：s1 != s2，idx是第一个不相等字符的下标 strcpy\nchar* strcpy(char* restrict dst, const char* restrict src);\n把src的字符串拷贝到dst，返回dst\nrestrict关键字：表明不重叠（C99）\nchar* dst = (char*) malloc(strlen(src) + 1); strcpy(dst, src); strcat\nchar* strcat(char* restrict s1, const char* restrict s2); 把s2拷贝到s1的后面，接成一个长的字符串，返回s1 s1必须有足够的空间 strcpy和strcat都可能出现安全问题，即目标没有足够的空间。尽可能不要使用这两个函数\n安全版本\nchar* strncpy(char* restrict dst, const char* restrict src, size_t n); char* strncat(char* restrict s1, const char* restrict s2, size_t n); strncmp\nint strncmp(const char *s1, const char *s2, size_t n); 比较前n个字符 strchr，strrchr\n字符串中找字符，一个从左开始，一个从右开始\nchar* strchr(const char* s, int c);\nchar* strrchr(const char* s, int c);\n返回指针，返回NULL表示没有找到\n找第二个\nchar s[] = \"Hello\"; char* p = strchr(s, 'l'); p = strchr(p + 1, 'l'); 找到后拷贝\nchar s[] = \"Hello\"; char* p = strchr(s, 'l'); // 拷贝后一段 { char* t = (char*) malloc(strlen(p) + 1); strcpy(t, p); printf(\"%s\\n\", t); free(t); } // 拷贝前一段 { char c = *p; *p = '\\0'; char* t = (char*) malloc(strlen(s) + 1); strcpy(t, s); *p = c; printf(\"%s\\n\", t); free(t); } strstr，strcasestr\n字符串中找字符串，strcasestr忽略大小写 char* strstr(const char* s1, const char* s2); char* strcasestr(const char* s1, const char* s2); strtok\n枚举 常量符号化：const 枚举是一种用户定义的数据类型，意义是给一些可以排列起来的常量值名字 enum typeName {name 1, name 2, ..., name n}; 枚举类型本质上是整型 声明枚举量可以指定值 枚举类型名字通常并不真的使用，要用的是大括号里的名字，因为它们就是常量符号，类型是int，值则依次从0到n 类型名字可以省略 定义枚举变量：enum typeName var = name 1; 枚举变量本质上是整型变量 套路：自动计数的枚举 enum COLOR {RED, YELLOW, GREEN, NumCOLORS}; 虽然枚举可以当作类型使用，但实际上很少用 如果有意义上排比的名字，用枚举比const int方便 枚举比宏好，因为枚举量有int类型 自定义数据类型 结构体 结构体变量的本质是变量的集合\n结构体变量中的成员占用独立的内存\n结构类型声明，定义结构体变量，访问成员变量，初始化\n// First form struct \u003cyourType\u003e { \u003ctype\u003e var1; \u003ctype\u003e var2; \u003ctype\u003e var3; }; struct \u003cyourType\u003e yourVar; // Second form struct { \u003ctype\u003e var1; \u003ctype\u003e var2; \u003ctype\u003e var3; }yourVar1, yourVar2; // Third form struct \u003cyourType\u003e { \u003ctype\u003e var1; \u003ctype\u003e var2; \u003ctype\u003e var3; }yourVar1, yourVar2; // access yourVar.var1 = \u003cvalue\u003e; // Initialisation struct \u003cyourType\u003e yourVar1 = {\u003cvalue1\u003e, \u003cvalue2\u003e, \u003cvalue3\u003e}; struct \u003cyourType\u003e yourVar1 = {.var1 = \u003cvalue1\u003e, .var2 = \u003cvalue2\u003e};\t// yourVar1.var3 == 0 在函数内部声明的结构类型只能在函数内部使用 通常在函数外部声明结构类型 不同无名结构体变量，尽管内部成员变量类型都相同，也不是同一数据类型 结构运算\n访问整个结构 赋值 struct var;\tvar = (struct ){, }; var1 = var2; 取地址 结构变量的名字并不是结构变量的地址，必须使用\u0026运算符 struct * pVar = \u0026var; 用指针变量访问结构成员：(*p).var或者**p-\u003evar** .，-\u003e优先级高于\u0026 传给函数参数 结构与函数\n整个结构作为参数的值传入函数 函数内新建一个结构变量，复制调用结构变量的值 可以返回一个结构 输入结构\n没有直接的方式可以一次scanf一个结构 可以自己写一个函数 struct getStruct(void); struct * getStruct(struct * p); 返回传进来的指针的好处是可以把程序连起来 结构数组\n结构中的结构\n位域：利用结构体类型指定成员变量占用内存的比特位宽度\n某些特殊场合，远古代码中可能被使用 位域成员必须是整型，占用位数不能超过类型宽度 当存储位不足时，自动启用新存储单元 可以舍弃当前未使用的位，重新启用存储单元 struct BW { unsigned char a : 4;\t// a 占用一个字节的4位宽度 unsigned char b : 5;\t// b 占用一个字节的5位宽度 unsigned char : 0;\t// 重启一个存储单元表示新的成员 unsigned char c : 2;\t// c 占用一个字节的2位宽度 } typedef 声明一个已有数据类型的新名字\n没有创建新类型，只是创建了类型别名\ntypedef ;\n改善了程序的可读性\n// typedef basic data type typedef unsigned char byte; // typedef function type int func(int a); int (*pFunc)(int) = func; typedef int(IFuncI)(int); IFuncI* pFunc = func; // typedef array type float array[5]; float (*pArray)[5] = \u0026array; typedef float(FArr5)[5]; FArr5* pArray = \u0026array; // typedef struct type typedef struct { double x; double y; } Node; Node aNode = {0.0, 0.0};\t// rather than struct Node aNode; 联合 union\n语法上和struct一样\nsizeof(union ) == sizeof(每个成员)的最大值\n所有成员共享一个空间\n同一时间只有一个成员是有效的\nunion类型的变量只能以第一个成员类型的有效值进行初始化\n应用\n判断系统大小端\nint isLittleEndian() { union { int i; char a[4]; }test; test.i = 1; return (test.a[0] == 1); } 宏 编译预处理指令：#开头\n预处理指令不是C语言的成分\n宏定义：#define 没有;因为不是C语句\n名字必须是单词，值可以是各种东西\n在C语言的编译器开始编译之前，编译预处理程序（The C Preprocessor）会把程序中的名字换成值\n预处理宏：简单的文本替换\n预处理器不会对宏定义进行语法检查\n如果一个宏的值中有其他宏的名字，也会被替换\n如果一个宏的值超过一行，最后一行之前的行末需要加\\\n宏的值后面出现的注释不会被当作宏的值的一部分\n宏定义之后，后面代码可以随意使用，没有作用域的概念\n没有值的宏\n例：#define _DEBUG 这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了 定义宏编译指令：gcc -DMACRO=1 file.c 预定义的宏\n__LINE__：当前所在行的行号 __FILE__：源代码文件的文件名 __DATE__：编译时的日期 __TIME__：编译时的时间 __STDC__：编译器是否遵循标准C规范，值为1或0 带参数的宏\n类似函数的宏 ()的原则 一切都要带括号 整个值要括号 参数出现的地方要括号 宏表达式中不能出现递归定义 宏和函数\n宏是由预处理器直接替换展开的，编译器不知道宏的存在，所以不安全\n函数是由编译器直接编译的实体，调用行为由编译器决定\n多次使用宏会导致最终可执行程序的体积增大\n函数是跳转执行的，内存中只有一份函数体存在\n宏的效率比函数要高，因为直接展开，无调用开销\n函数调用时会创建活动记录，效率不如宏\n使用原则\n能用函数实现的使用函数\n宏可以用于生成一些常规性的代码；封装函数，加上类型信息\n// 函数封装 #define MALLOC(type, x) (type*)malloc(sizeof(type) * x) #define FREE(p) (free(p), p = NULL) #define LOG_INT(i) printf(\"%s = %d\\n\", #i, i) #define LOG_CHAR(c) printf(\"%s = %c\\n\", #c, c) #define LOG_STRING(s) printf(\"%s = %s\\n\", #s, s) #define FOREACH(i, n)\tfor(int i = 0; i \u003c n; i++) #define BEGIN\t{ #define END\t} 多文件程序设计 一个源代码文件太长了适合分成几个文件\n工程项目 -\u003e 功能X，Y，Z…\n编译和链接\n一个.c文件是一个编译单元\n编译器每次编译只处理一个编译单元\n编译完形成.o文件，目标代码文件\nA file ending in .o is an object file. The compiler creates an object file for each source file, before linking them together, into the final executable.\n多个.o文件链接起来得到可执行文件.exe\n文件可以定义为功能接口（可被其他文件的函数或数据）\n源文件：代码实现文件，.c 标准库的函数代码实现在某个.lib（Windows）或.a（Unix）中 头文件：源文件的接口定义文件，.h 声明和定义\n声明是不产生代码的东西，意义是告诉编译器程序单元的存在 C语言中通过extern进行程序单元的声明，一些程序单元可以省略该关键字 函数原型 变量声明 结构声明 宏声明 枚举声明 类型声明 inline函数 定义是产生代码的东西，意义是指示程序单元的意义 头文件.h\n存放声明 规矩上，只有声明可以被放在头文件中 如果放定义，会造成一个项目中多个编译单元里有重名的实体 某些编译器允许几个编译单元中存在同名函数，或者用weak修饰符来强调这种存在 在需要调用头文件中的函数的源代码文件.c中#include这个头文件，就能让编译器在编译的时候知道这个函数的原型，保证你调用时给出的参数值和返回值是正确的类型 #include是一个编译预处理指令，会把那个文件的全部文本内容原封不动地插入到他所在的地方 #include的两种形式 \"\"：要求编译器首先在当前目录中（.c文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找 \u003c\u003e：让编译器只在指定的目录去找 编译器自己知道自己的标准库的头文件在哪里，环境变量和编译器命令行参数也可以指定寻找头文件的目录 现在的C语言编译器默认会引入所有的标准库 在使用和定义函数的地方都应该#include这个头文件 使用：编译器可以检查函数调用的正确性 定义：编译器可以检查对外宣称的函数原型和实际定义是否一致 一般的做法是任何的.c都有对应的同名.h（main.c除外），把所有对外公开的函数的原型和全局变量的声明都放进去 不对外公开的函数：static修饰，使得该函数只能在所在的编译单元中被使用 静态全局变量static修饰，使得它成为只能在所在的编译单元中被使用的全局变量 普通全局变量的声明：extern ; 标准头文件结构\n重复声明问题\n同一个编译单元里，同名的结构不能被重复声明 如果你的头文件里有结构的声明，很难让这个头文件不会在一个编译单元里被#include多次 所以需要标准头文件结构 运用条件编译和宏，保证这个头文件在一个编译单元中只会被#include一次\n#ifndef _LIST_H_ #define _LIST_H_ #include \"node.h\" typedef struct _list { Node* head; Node* tail; } List; #endif #progma once也能起到相同的作用，但不是所有的编译器都支持\n简论编译和链接 编译器（广义）\n预处理器\n编译器\n汇编器\n链接器\ngraph LR;\rA((file.c))\rB((file.h))\rC(预处理器)\rA --\u003e C\rB --\u003e C\rD((file.i))\rE(编译器)\rC --\u003e D\rD --\u003e E\rF((file.s))\rG(汇编器)\rE --\u003e F\rF --\u003e G\rH((file.o))\rG --\u003e H 预编译\n生成中间文件.i 处理所有的注释，以空格代替 将所有的#define删除，并且展开所有的宏定义 处理条件编译指令#if, #ifdef, #elif, #else, #endif 处理#include，展开被包含的文件 保留编译器需要使用的#pragma指令 预处理指令：gcc -E file.c -o file.i 编译\n对预处理文件进行词法分析，语法分析和语义分析 词法分析：分析关键字，标识符，立即数等是否合法 语法分析：分析表达式是否遵循语法规则 语义分析：在语法分析的基础上进一步分析表达式是否合法 分析结束后进行代码优化生成相应的汇编代码文件 编译指令：gcc -S file.c -o file.s 汇编\n汇编器将汇编代码转变为机器的可执行指令 生成机器代码目标文件.o 汇编指令：gcc -c file.s -o file.o 链接\n链接器的主要作用是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确的衔接\n静态链接：链接器在链接时将库的内容直接加入到可执行程序中，执行时与原来的那些文件没有关系\ngraph TB;\rA((file1.o))\rB((file2.o))\rC((libc.a))\rD(链接器)\rE((a.out))\rA --\u003e D\rB --\u003e D\rC --\u003e D\rD --\u003e E Linux下静态库的创建和使用 编译静态库源码：gcc -c lib.c -o lib.o 生成静态库文件：ar -q lib.a lib.o 使用静态库编译：gcc main.c lib.a -o main.out 动态链接：可执行程序在运行时才动态加载库进行链接，库的内容不会进入可执行程序当中\ngraph LR;\rA((lib1.so))\rB((lib2.so))\rC[stub1]\rD[stub2]\rE(链接器)\rF((a.out))\rA --- C\rB --- D\rC --\u003e E\rD --\u003e E\rE --\u003e F Linux下动态库的创建和使用 编译动态库源码：gcc -shared dlib.c -o dlib.so 使用动态库编译：gcc main.c -lbl -o main.out 关键系统调用： dlopen：打开动态库文件 dlsym：查找动态库中的函数并返回调用地址 dlclose：关闭动态库文件 条件编译\n条件编译是预编译指示命令，用于控制是否编译某段代码\n#if (C == 1) /* #ifdef C #ifndef C */ // statements #else //statements #endif 实际工程中条件编译主要用于以下两种情况：\n不同产品线共用一份代码 区分编译产品的调试版和发布版 #error，#warning\n用于生成一个自定义的编译错误消息/警告\n用法：#error message，message不需要双引号\n是一个预编译器指示字\n可用于提示编译条件是否满足\n例：\n#ifndef __cplusplus #error This file should be processed with C++ compiler. #endif 编译过程中的任意错误信息意味着无法生成最终的可执行程序\n#pragma\n用于指示编译器完成一些特定的动作\n#pragma所定义的很多指示字是编译器特有的\n在不同的编译器间是不可移植的\n预处理器将忽略它不认识的#pragma指令 不同的编译器可能以不同的方式解释同一条#pragma指令 用法：#pragma parameter\n#pragma message message参数在大多数的编译器中都有相似的实现 在编译时输出消息到编译输出窗口中 可以用于条件编译中提示代码的版本信息 输入输出 格式化输入输出\nprintf：%[flag][width][.prec][hIL]type\nFlag 含义 - 左对齐 + 在前面放+或- (space) 正数留空 0 0填充 width, prec 含义 number 最小字符数 * 指代参数是字符数 .number 小数点后的位数 .* 指代参数是小数点后的位数 hIL 含义 hh 单个字节 h short l long ll long long L long double type 用于 i / d int u / U unsigned int o / O 八进制 x 十六进制 X 字母大写的十六进制 f / F float，6位 e / E 指数 g float G float a / A 十六进制浮点 c char s 字符串 p 指针 n 读入/写出的个数 scanf：%[flag]type\nFlag 含义 * 跳过 number 读入最大字符数 hh char h short l long, double ll long long L long double type 用于 d int i int，可以接受十六进制或八进制 u unsigned int o 八进制 x 十六进制 a, e, f, g float c char s 字符串 [...] 所允许的字符 p 指针 printf返回输出的字符数，scanf返回读入的项目数\n文件输入输出\n程序运行重定向：\u003c， \u003e\nFILE\n标准库里声明的类型\nFILE* fopen(const char* restrict path, const char* restrict mode); int fclose(FILE* stream); fscanf(FILE*, ...); fprintf(FILE*, ...); // 打开文件的标准代码 FILE* fp = fopen(\"file\", \"r\"); if(fp) { fscanf(fp, ...); fclose(fp); } else { // ... } /* r:\t打开只读 r+:\t打开读写，从文件头开始 w:\t打开只写。如果不存在则新建，如果存在则清空 w+:\t打开读写。如果不存在则新建，如果存在则清空 a:\t打开追加。如果不存在则新建，如果存在则从文件尾开始 ..x:\t只新建，如果文件已存在则不能打开 */ 文本文件 vs 二进制文件\n本质上，所有文件都是二进制文件\n文本文件无非是用最简单的方式可以读写的文件\n二进制文件是需要专门的程序来读写的文件\n文本文件的输入输出是格式化，可能经过转码\nUnix喜欢用文本文件来做数据存储和程序配置；Windows喜欢用二进制文件\n文本的优点是方便人类读写，而且跨平台；缺点是输入输出要经过格式化，开销大\n二进制的优点是程序读写快，缺点是人类读写困难，而且不跨平台\n程序为什么要文件\n配置：Unix用文本，Windows用注册表 数据：稍微有点量的数据都放数据库了 媒体：只能是二进制 现实是，程序通过第三方库来读写文件，很少直接读写二进制文件做底层操作\n程序的基本数据区 栈 用于维护函数调用上下文 保存了参数，返回地址，old ebp，寄存器信息，局部变量，其他数据信息 后进先出，栈底栈顶 每次函数调用都对应着栈上的一个活动记录 调用函数的活动记录位于栈的中部 被调函数的活动记录位于栈的顶部 函数调用时，对应的栈空间在函数返回前是专用的 函数调用结束后，栈空间将被释放，数据不再有效；在调用下一个函数前数据仍然存在 堆 堆是程序中一块预留的内存空间，可由程序自由使用 堆中被程序申请的内存在被主动释放前将一直有效 为什么有了栈还需要堆？ 栈上的数据在函数返回后就会被释放掉，无法传递到函数外部 系统对堆空间的管理方式：空闲链表法，位图法，对象池法等 静态存储区 随着程序的运行而分配空间 生命周期直到程序运行结束 在程序的编译期静态存储区的大小就已经确定 主要用于保存全局变量和静态局部变量 静态存储区的信息最终会保存到可执行程序中 程序的内存布局 可执行文件的布局：File Header | .text | .data | .bss 映射到进程的地址空间：stack | heap | .bss | .data | .text | 未映射区域 堆栈段在程序运行后才正式存在 .bss段存放的是未初始化的全局变量和静态变量 .text段存放的是程序中的可执行代码 .data段保存的是已经初始化了的全局变量和静态变量 .rodata段存放程序中的常量值，如字符串常量 静态存储区通常指程序中的.bss和.data段 只读存储区通常指程序中的.rodata段 ","wordCount":"2454","inLanguage":"en","datePublished":"2022-02-06T00:00:00Z","dateModified":"2022-02-06T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://hadjshell.github.io/posts/c-notes/"},"publisher":{"@type":"Organization","name":"Hadjshell","logo":{"@type":"ImageObject","url":"https://hadjshell.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hadjshell.github.io/ accesskey=h title="Hadjshell (Alt + H)"><img src=https://hadjshell.github.io/apple-touch-icon.png alt aria-label=logo height=35>Hadjshell</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hadjshell.github.io/ title=Home><span>Home</span></a></li><li><a href=https://hadjshell.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://hadjshell.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hadjshell.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://hadjshell.github.io/posts/>Posts</a></div><h1 class=post-title>C Notes</h1><div class=post-meta><span title='2022-02-06 00:00:00 +0000 UTC'>February 6, 2022</span></div></header><div class=post-content><h1 id=c-notes>C Notes<a hidden class=anchor aria-hidden=true href=#c-notes>#</a></h1><hr><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href="https://www.bilibili.com/video/BV19W411B7w1?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">C语言程序设计 - 翁恺</a></li><li>Kernighan, B.W. & Ritchie, D.M. (1988) The C programming language. 2nd ed.. Englewood Cliffs, N.J.: Prentice Hall.</li></ul><hr><h2 id=导论>导论<a hidden class=anchor aria-hidden=true href=#导论>#</a></h2><ul><li><p>计算机的思维方式：枚举</p></li><li><p>算法改进暴力枚举</p></li><li><p>程序的执行：</p><ul><li><p>解释：借助一个程序，那个程序试图理解你的程序，然后按照你的要求执行</p></li><li><p>编译：借助一个程序，把你的程序翻译成机器语言，然后执行机器语言的程序</p><blockquote><p>编译是将源程序翻译成可执行的目标代码，翻译与执行是分开的；而解释是对源程序的翻译与执行一次性完成，不生成可存储的目标代码。这只是表象，二者背后的最大区别是：对解释执行而言，程序运行时的控制权在解释器而不在用户程序；对编译执行而言，运行时的控制权在用户程序。</p></blockquote></li><li><p>语言本身没有解释和编译之分，只是具体执行方式不同</p></li><li><p>现代两种执行方式已经没有过大的区别，各有优劣</p></li></ul></li><li><p>现代编程语言语法上差异很小，几乎都是C-like语言</p></li><li><p>某些场景，例如操作系统，只能用C写</p></li><li><p>语言的能力/适用领域主要决定因素：</p><ul><li>库</li><li>传统</li></ul></li><li><p>FORTRAN -> BCPL -> B -> C</p><blockquote><p>C implementations give a better understanding of how the machine behaves. There is no language runtime environment or virtual machine between you and the underlying machine.</p></blockquote></li><li><p>标准：<code>ANSI C</code> -> <code>C99</code></p></li><li><p>C is a general-purpose programming language.</p></li><li><p>指针是C的灵魂</p></li><li><p>C的应用场景：</p><ul><li>操作系统，编译器</li><li>嵌入式系统</li><li>驱动程序</li><li>底层驱动</li><li>图形引擎、图像处理、声音效果</li></ul></li><li><p>Ｃ是一种工业语言</p><ul><li>开发效率＞＞学习过程</li><li>开发效率＞＞开发乐趣</li></ul></li><li><p>历史原因，Ｃ的编译器有很多，出现了“方言”现象</p></li></ul><hr><h2 id=变量和常量>变量和常量<a hidden class=anchor aria-hidden=true href=#变量和常量>#</a></h2><ul><li>变量是一个保存数据的地方，是一段存储空间的别名</li><li>变量定义：<code>&lt;type> &lt;identifier>;</code></li><li>标识符：字母，数字，下划线；第一个字符必须为字母或下划线；大小写敏感；不能用保留字</li><li>赋值：<code>=</code>右边的值赋给左边的变量</li><li>初始化：定义变量时赋值</li><li>没有初始化的变量，值为随机数</li><li>C语言类型严格</li><li><code>C99</code>可以在任意位置定义变量；<code>ANSI C</code>只能在代码开头定义变量</li><li>字面量（literal）：直接写在程序里的数值（magic number）</li><li>常量定义：<code>const &lt;type> &lt;identifier> = &lt;value></code></li><li>常量好处：物理意义；便于Debug</li></ul><hr><h2 id=数据类型>数据类型<a hidden class=anchor aria-hidden=true href=#数据类型>#</a></h2><ul><li><p>C语言的变量，必须：</p><ul><li>在使用前定义</li><li>确定类型</li></ul></li><li><p>C以后的语言向两个方向发展：</p><ul><li><p>C++，Java更强调类型，对类型检查严格</p></li><li><p>JavaScript，Python，PHP不看重类型，甚至不需要事先定义</p><blockquote><p>支持强类型的观点认为明确的类型有助于尽早发现程序中的简单错误</p><p>反对强类型的观点认为多于强调类型迫使程序员面对底层实现而非事务逻辑</p></blockquote></li></ul></li><li><p>C语言需要类型，但是对类型的安全检查并不够</p></li><li><table><thead><tr><th>类型</th><th>关键字</th></tr></thead><tbody><tr><td>整数</td><td><code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code></td></tr><tr><td>浮点数</td><td><code>float</code>, <code>double</code>, <code>long double</code></td></tr><tr><td>逻辑</td><td><code>bool</code></td></tr><tr><td>指针</td><td></td></tr><tr><td>自定义类型</td><td></td></tr></tbody></table></li><li><p>数据类型的区别：</p><ul><li>内存中占据的大小</li><li>内存中的表达形式：补码，编码</li></ul></li><li><p><code>sizeof()</code>：是一个运算符，给出某个<strong>类型</strong>或<strong>变量</strong>在内存中所占据的字节数</p><ul><li>静态运算符，结果在编译时刻就决定了</li><li>不要在<code>sizeof</code>的括号里做运算，这些运算是不会做的</li></ul></li><li><p>字面量也有数据类型</p><ul><li>默认<code>int, double, char, string</code></li><li>可以指定类型：加后缀</li></ul></li></ul><h3 id=整型>整型<a hidden class=anchor aria-hidden=true href=#整型>#</a></h3><ul><li><table><thead><tr><th>类型</th><th>字节</th></tr></thead><tbody><tr><td><code>char</code></td><td>1</td></tr><tr><td><code>short</code></td><td>2</td></tr><tr><td><code>int</code></td><td>取决于编译器（CPU）</td></tr><tr><td><code>long</code></td><td>取决于编译器（CPU）</td></tr><tr><td><code>long long</code></td><td>8</td></tr></tbody></table></li><li><p>计算机内部表达：补码</p></li><li><table><thead><tr><th>类型</th><th>范围</th></tr></thead><tbody><tr><td><code>char</code></td><td>-128 ~ 127</td></tr><tr><td><code>short</code></td><td>-32768 ~ 32767</td></tr><tr><td><code>int</code></td><td>-231 ~ 231 - 1 (-2147483648 ~ 2147483647)</td></tr></tbody></table></li><li><p><code>unsigned</code></p><ul><li>初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位</li></ul></li><li><p>整数是以纯二进制方式进行运算的</p></li><li><p>整数越界</p></li><li><table><thead><tr><th>格式化输入输出</th><th>类型</th></tr></thead><tbody><tr><td><code>%d</code></td><td><code>char, short, int, long</code></td></tr><tr><td><code>%u</code></td><td><code>unsigned</code></td></tr><tr><td><code>%ld</code></td><td><code>long long</code></td></tr><tr><td><code>%lu</code></td><td><code>unsigned long long</code></td></tr><tr><td><code>%o</code></td><td>8进制</td></tr><tr><td><code>%x</code></td><td>16进制</td></tr></tbody></table></li><li><p>以<code>0</code>开始的数字字面量是8进制；以<code>0x</code>开始的数字字面量是16进制</p></li><li><p>为什么有这么多整数类型？</p><ul><li>为了准确表达内存，做<strong>底层程序</strong>的需要</li><li>历史原因</li></ul></li><li><p>没有特殊需要，选择<code>int</code></p><ul><li>现在CPU字长普遍32位或64位，一次内存读写就是一个<code>int</code>，一次计算也是一个<code>int</code>，选择更短的类型不会更快，甚至可能更慢</li><li>现代编译器一般会设计内存对齐，所以更短的类型实际在内存中有可能也占据一个<code>int</code>的大小</li><li><code>unsigned</code>与否只是输出的不同，内部计算是一样的</li></ul></li></ul><h3 id=浮点类型>浮点类型<a hidden class=anchor aria-hidden=true href=#浮点类型>#</a></h3><ul><li><table><thead><tr><th>类型</th><th>字长</th><th>范围</th><th>有效数字</th></tr></thead><tbody><tr><td><code>float</code></td><td>32</td><td>$\pm(1.20 * 10^{-38} - 3.40 * 10^{38}), 0, \pm inf, nan$</td><td>7</td></tr><tr><td><code>double</code></td><td>64</td><td>$\pm(2.20 * 10^{-308} - 1.79 * 10^{308}), 0, \pm inf, nan$</td><td>15</td></tr></tbody></table><ul><li><p><code>printf</code>输出<code>inf</code>表示超过范围的浮点数，输出<code>nan</code>表示不存在的浮点数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mf>12.0</span> <span class=o>/</span> <span class=mf>0.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>-</span><span class=mf>12.0</span> <span class=o>/</span> <span class=mf>0.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mf>0.0</span> <span class=o>/</span> <span class=mf>0.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>Output</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=n>inf</span>
</span></span><span class=line><span class=cl><span class=o>-</span><span class=n>inf</span>
</span></span><span class=line><span class=cl><span class=n>nan</span>
</span></span></code></pre></div></li></ul></li><li><table><thead><tr><th>类型</th><th><code>scanf</code></th><th><code>printf</code></th></tr></thead><tbody><tr><td><code>float</code></td><td><code>%f</code></td><td><code>%f, %e</code></td></tr><tr><td><code>double</code></td><td><code>%lf</code></td><td><code>%f, %e</code></td></tr></tbody></table><ul><li><code>%e</code>：科学计数法格式</li><li>字面量也可使用科学计数法格式，例：<code>1e-10</code></li><li>输出精度，例：<code>%.5f</code>，四舍五入</li></ul></li><li><p>浮点类型对数据的表示是不准确的，是近似的</p><ul><li>二进制能表示的数是有限的，但数是连续的</li></ul></li><li><p>浮点运算没有精度</p><ul><li>不能直接比较</li><li>误差会累积</li><li>转而使用整型解决实际问题</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=mf>1.345f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=mf>1.123f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=mf>2.468</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Equal!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Not equal! c = %.10f, or %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// f1 == f2 可能失败
</span></span></span><span class=line><span class=cl><span class=c1>// fabs(f1 - f2) &lt; 1e-12 来比较
</span></span></span></code></pre></div></li><li><p>浮点数内部表达：编码</p></li><li><p>浮点数在计算时是由专用的硬件部件实现的</p></li><li><p>没有特殊需要，使用<code>double</code></p></li></ul><h3 id=字符类型>字符类型<a hidden class=anchor aria-hidden=true href=#字符类型>#</a></h3><ul><li><code>char</code>既是整型，也是字符型</li><li>格式化输入输出：<code>%c</code></li><li>字符字面量：<code>''</code>表示</li><li>ASCII码</li></ul><h4 id=转义字符-escape-character>转义字符-Escape character<a hidden class=anchor aria-hidden=true href=#转义字符-escape-character>#</a></h4><ul><li><p>用来表达无法打印出来的控制字符或特殊字符，由<code>\</code>开头，后面跟上一个字符</p></li><li><table><thead><tr><th>常用转义字符</th><th>意义</th></tr></thead><tbody><tr><td><code>\b</code></td><td>回退一格</td></tr><tr><td><code>\t</code></td><td>到下一个表格位</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\"</code></td><td>双引号</td></tr><tr><td><code>\'</code></td><td>单引号</td></tr><tr><td><code>\\</code></td><td>反斜杠本身</td></tr></tbody></table><ul><li>回退一般不代表删除</li><li>制表位：每行的固定位置，而不是固定大小的字符数量</li><li>换行实际上是回车和换行两个动作</li></ul></li></ul><h3 id=类型转换>类型转换<a hidden class=anchor aria-hidden=true href=#类型转换>#</a></h3><h4 id=自动类型转换>自动类型转换<a hidden class=anchor aria-hidden=true href=#自动类型转换>#</a></h4><ul><li>当运算符两边出现不一致的类型时，会自动转换成较大的类型</li><li><code>char -> short -> int -> long -> long long</code></li><li><code>int -> float -> double</code></li><li>对于<code>printf</code>，任何小于<code>int</code>的类型会被转换成<code>int</code>，<code>float</code>会被转换成<code>double</code></li><li><code>scanf</code>不会</li></ul><h4 id=强制类型转换>强制类型转换<a hidden class=anchor aria-hidden=true href=#强制类型转换>#</a></h4><ul><li><code>(type) value</code></li><li>注意安全性</li><li>只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型</li><li>强制类型转换的优先级高于四则运算</li></ul><h3 id=逻辑类型>逻辑类型<a hidden class=anchor aria-hidden=true href=#逻辑类型>#</a></h3><ul><li>C语言原本是没有<code>bool</code>类型的</li><li><code>#include &lt;stdbool.h></code></li><li>之后可以使用<code>true</code>，<code>false</code></li><li>实际上是整型，<code>1</code>和<code>0</code></li></ul><hr><h2 id=运算>运算<a hidden class=anchor aria-hidden=true href=#运算>#</a></h2><ul><li><p>表达式：一系列运算符和操作数的组合</p></li><li><p>运算符（operator）</p><table><thead><tr><th>运算类型</th><th>运算符</th></tr></thead><tbody><tr><td>四则</td><td>+ - * / % ()</td></tr><tr><td>关系</td><td>&lt; > &lt;= >= == !=</td></tr><tr><td>逻辑</td><td>&& || !</td></tr><tr><td>位</td><td>& | ^ &#187; &#171; ~</td></tr><tr><td>单目</td><td>+ -</td></tr><tr><td>赋值</td><td>=</td></tr><tr><td>复合赋值</td><td>+= -= *= /= %=</td></tr><tr><td>递增递减</td><td>++ &ndash;</td></tr><tr><td>条件</td><td>? :</td></tr><tr><td>逗号</td><td>,</td></tr></tbody></table></li><li><p>操作数（operand）</p></li></ul><h3 id=四则>四则<a hidden class=anchor aria-hidden=true href=#四则>#</a></h3><ul><li>整型除法舍弃小数部分</li><li>浮点数不能取余</li><li>优先级：正负 > 乘除 > 取余 > 加减 > 赋值</li></ul><h3 id=赋值>赋值<a hidden class=anchor aria-hidden=true href=#赋值>#</a></h3><ul><li>赋值也是运算，也有结果</li><li>例：<code>a = 6</code>的结果是<code>6</code></li><li>自右向左结合</li></ul><h3 id=递增递减>递增递减<a hidden class=anchor aria-hidden=true href=#递增递减>#</a></h3><ul><li>前缀：<code>a++</code>结果是<code>a</code>加<code>1</code>以前的值</li><li>后缀：<code>++a</code>结果是<code>a</code>加<code>1</code>以后的值</li><li><code>a + 1</code>是附作用</li></ul><h3 id=关系>关系<a hidden class=anchor aria-hidden=true href=#关系>#</a></h3><ul><li>比较结果：逻辑值真1假0</li><li>优先级比算术低，比赋值高</li><li>连续的关系运算从左向右执行</li></ul><h3 id=逻辑>逻辑<a hidden class=anchor aria-hidden=true href=#逻辑>#</a></h3><ul><li>短路法则：逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算</li></ul><h3 id=逗号>逗号<a hidden class=anchor aria-hidden=true href=#逗号>#</a></h3><ul><li>逗号用来连接两个表达式，并以右边的表达式的值作为它的结果</li><li>逗号运算符的优先级是最低的</li><li>主要在<code>for</code>中使用</li></ul><h3 id=位运算>位运算<a hidden class=anchor aria-hidden=true href=#位运算>#</a></h3><ul><li>直接对二进制位进行操作</li><li>按位与常用于：<ul><li>让某一位或某些位为0：和0与</li><li>取一个数中的一段：<code>x & 0x00ff0000</code></li></ul></li><li>按位或常用于：<ul><li>使得一位或一些位为1：和1或</li><li>把两个数拼起来：<code>0x00ff | 0xff00</code></li></ul></li><li>按位异或：相同为0，不同为1<ul><li>某位取反：和1异或</li><li>某位不变：和0异或</li></ul></li><li>左移<ul><li>高位移出，低位补零</li><li>所有小于<code>int</code>的类型，移位以<code>int</code>的方式做，结果是<code>int</code></li><li><code>x &lt;&lt;= 1 == x *= 2</code></li></ul></li><li>右移<ul><li>低位移出，高位补符号位</li><li><code>x >>= 1 == x /= 2</code></li></ul></li></ul><hr><h2 id=流程控制>流程控制<a hidden class=anchor aria-hidden=true href=#流程控制>#</a></h2><ul><li>结构化的基石</li><li>块：<code>{}</code></li></ul><h3 id=选择>选择<a hidden class=anchor aria-hidden=true href=#选择>#</a></h3><h4 id=if---else>If - else<a hidden class=anchor aria-hidden=true href=#if---else>#</a></h4><ul><li>二路分支</li><li>嵌套</li><li>级联</li><li>else总是和最近的if匹配</li><li>“单一出口”原则</li></ul><h4 id=switch>Switch<a hidden class=anchor aria-hidden=true href=#switch>#</a></h4><ul><li>多路分支</li><li>控制表达式只能是整数型</li><li><code>case</code>常量可以是常数，也可以是常数计算的表达式</li><li><code>case</code>判断代码块内执行的开始<ul><li>合并分支</li></ul></li><li><code>break</code>语句，没有<code>break</code>会顺序向下执行</li><li>默认情况执行<code>default</code>下的语句</li><li><code>default</code>不是必须但是最好有</li></ul><h3 id=循环>循环<a hidden class=anchor aria-hidden=true href=#循环>#</a></h3><h4 id=while>While<a hidden class=anchor aria-hidden=true href=#while>#</a></h4><ul><li>先判断条件再执行循环体</li></ul><h4 id=do-while>Do while<a hidden class=anchor aria-hidden=true href=#do-while>#</a></h4><ul><li>先执行一次循环体再判断条件</li></ul><h4 id=for>For<a hidden class=anchor aria-hidden=true href=#for>#</a></h4><ul><li><p>如果有固定次数，用<code>for</code>；如果必须执行一次，用<code>do while</code>；其他情况用<code>while</code></p></li><li><p>循环控制：<code>break</code>，<code>continue</code>；最近匹配原则，针对当前循环</p><blockquote><p><code>break</code>对<code>if-else</code>不起作用</p></blockquote></li><li><p>循环嵌套</p></li><li><p>跳出多重循环：<code>goto</code></p></li><li><p>给定条件的整数集：枚举 + 剔除</p></li></ul><hr><h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2><ul><li><p>函数是可以重复利用的代码块，接受零个或多个参数，做一件事情，并返回零个或一个值</p></li><li><p>函数本质是占用一片连续内存的代码</p></li><li><p>函数定义</p><ul><li>函数头：返回类型 函数名 参数列表</li><li>函数体</li></ul></li><li><p>函数调用：<code>函数名(参数值);</code></p><ul><li>执行 -> 调用函数 -> 执行调用函数 -> 返回 -> 恢复执行</li></ul></li><li><p>函数返回：<code>return</code></p><ul><li><code>return</code>停止函数的执行，并返回一个值</li><li><code>return;</code>, <code>return exp;</code></li></ul></li><li><p><code>void</code></p><ul><li><code>void</code>不能用于定义变量</li><li>用于函数定义，表示无返回值或无参数</li><li><code>type func();</code>表示接受任意多的参数</li></ul></li><li><p>函数的先后关系</p><ul><li>C的编译器自上而下顺序分析</li><li>调用函数需要先声明或定义</li><li>声明定义要一致</li></ul></li><li><p>参数传递</p><ul><li>值传递</li><li>调用函数时给的值与参数类型不匹配是C语言传统上最大的漏洞，编译器会隐式地进行类型转换</li><li>每个函数有自己的变量空间，参数也位于这个空间中</li></ul></li><li><p>变量分类</p><ul><li>局部（本地）变量：函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数这次运行所独有的，称作局部变量<ul><li>定义在函数内部的变量，参数</li><li>定义在语句块内的变量</li><li>只能在当前<strong>块</strong>中访问使用</li><li>块外定义变量在块内仍然有效</li><li>本地变量<strong>不会被默认初始化</strong></li><li>参数在进入函数时会初始化</li></ul></li><li>全局变量：定义在函数外面的变量<ul><li>没有初始化的全局变量会得到<code>0</code>值</li><li>指针会得到<code>null</code>值</li><li>只能用编译时已知的值来初始化全局变量</li><li>全局变量初始化发生在<code>main</code>函数之前</li><li>工程中，全局变量通常以<code>g</code>作为前缀命名</li></ul></li><li>同名变量<ul><li>不同块中的局部变量可以同名</li><li>同一块中的局部变量不可以同名</li><li>块内同名变量覆盖块外同名变量</li></ul></li><li>静态变量：<code>static</code><ul><li>静态本地变量<ul><li>作用域：块内；生命期：程序生命期</li><li>静态本地变量只会在第一次进入函数时初始化一次</li><li>离开函数时，静态本地变量会继续存在并保持其值</li><li>特殊的全局变量，创建于全局数据区</li></ul></li><li>静态全局变量<ul><li>作用域：文件作用域；生命期：程序生命期</li></ul></li></ul></li><li>使用全局变量和静态本地变量的函数是线程不安全的</li></ul></li><li><p>作用域：变量定义后的可访问范围</p><ul><li>局部变量：定义开始到代码块结束</li><li>全局变量：程序的任何地方</li></ul></li><li><p>生命期：变量从创建到销毁的时间</p><ul><li>局部变量：进入作用域时创建，离开作用域时自动销毁</li><li>全局变量：程序开始运行时创建，程序结束时自动销毁</li></ul></li><li><p>调用函数里的<code>,</code>不是运算符</p></li><li><p>C语言不允许函数嵌套定义，可以放声明</p></li><li><p>C语言程序的入口：<code>main</code>函数</p><ul><li><code>main()</code>是应用程序与操作系统的“约定”</li></ul></li><li><p>C语言可以定义参数可变的函数</p><ul><li>参数可变函数的实现依赖于<code>stdarg.h</code></li><li><code>va_list</code>：参数集合</li><li><code>va_arg</code>：取具体参数值</li><li><code>va_start</code>：标识参数访问的开始</li><li><code>va_end</code>：标识参数访问的结束</li><li>可变参数必须从头到尾按照顺序逐个访问</li><li>参数列表中至少要存在一个确定的命名参数</li><li>可变参数函数无法确定实际存在的参数的数量</li><li>可变参数函数无法确定参数的实际类型</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdarg.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>average</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=p>...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>va_list</span> <span class=n>args</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>va_start</span><span class=p>(</span><span class=n>args</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=o>+=</span> <span class=n>va_arg</span><span class=p>(</span><span class=n>args</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>va_end</span><span class=p>(</span><span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sum</span> <span class=o>/</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>average</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>average</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p>函数设计原则</p><ul><li>函数从意义上应该是一个独立的功能模块</li><li>函数名要在一定程度上反映函数的功能</li><li>函数参数名要能够体现参数的意义</li><li>尽量避免在函数中使用全局变量</li><li>当函数参数不应该在函数体内部被修改时，应该加上<code>const</code>声明</li><li>如果参数是指针，且仅作输入参数，则应加上<code>const</code>声明</li><li>不能省略返回值的类型</li><li>对参数进行有效性检查，对指针参数的检查尤为重要</li><li>函数体的规模要小，尽量控制在80行代码之内</li><li>相同的输入对应相同的输出，避免有状态函数</li><li>避免函数有过多的参数，尽量控制在4个以内<ul><li>太多可以考虑结构体</li></ul></li><li>有时候函数不需要返回值，但为了增加灵活性，如支持链式表达，可以附加返回值</li></ul></li></ul><hr><h2 id=数组>数组<a hidden class=anchor aria-hidden=true href=#数组>#</a></h2><ul><li>数组是相同数据类型变量的有序集合</li><li>数组定义：<code>&lt;type> identifier[size];</code></li><li>数组类型：<code>&lt;type>[size]</code></li><li>元素数量必须是整数，必须是编译时刻确定的字面量<ul><li><strong><code>C99</code>之后可以使用变量</strong></li></ul></li><li>数组在计算机内是一片连续的内存</li><li>数组一旦创建，<strong>不能改变大小</strong></li><li>数组访问：<code>identifier[index]</code><ul><li>数组下标从<code>0</code>开始</li><li>可以使用变量作为下标</li><li>编译器和运行环境都不会检查数组下标是否越界，无论读写</li><li>一旦程序运行，数组越界<strong>可能</strong>造成问题，导致程序崩溃</li><li>不同机器上无法复现程序的一大问题：没有考虑数组越界</li></ul></li><li>长度为0数组可以定义，但是无用，自然越界</li><li>数组初始化<ol><li><code>&lt;type> identifier[N] = {v0, v1, ..., vn-1};</code> 不初始化是随机值</li><li>自动确定数组大小：<code>&lt;type> identifier[] = {v0, v1, ..., vn-1};</code></li><li>部分初始化：<code>&lt;type> identifier[N] = {[0] = 2, [2] = 3, 6, };</code><ul><li>用<code>[n]</code>在初始化数据中给出定位</li><li>没有定位的数据姐在前面的位置后面</li><li>其他位置补零</li><li>适合初始数据稀疏的数组</li></ul></li></ol></li><li>数组大小：<code>sizeof(identifier)</code></li><li>数组个数：<code>sizeof(identifier) / sizeof(identifier[0])</code></li><li>数组变量本身不能被赋值。要想拷贝一个数组，只能遍历</li><li>数组作为函数参数时，往往必须再用另一个参数来传入数组的大小</li><li>数组变量本身表达地址，无需用<code>&</code>取地址；数组单元表达的是变量</li><li>二维数组<ul><li><code>&lt;type> identifier[M][N];</code></li><li>通常理解为M行N列的矩阵，或者M个大小为N的一维数组</li><li>二维数组初始化列数必须给出，行数可以自动确定</li><li>检查行</li><li>检查列</li><li>检查对角线，反对角线</li></ul></li><li><code>const</code>数组<ul><li><code>const &lt;type> identifier[] = {0, };</code></li><li>表明每个数组单元都是<code>const</code></li><li>必须通过初始化进行赋值</li><li><strong>保护数组</strong>不被函数破坏</li></ul></li></ul><hr><h2 id=指针>指针<a hidden class=anchor aria-hidden=true href=#指针>#</a></h2><ul><li><p><code>&</code>运算符：获得变量的地址，他的操作数必须是变量</p><ul><li>格式化输出：<code>%p</code></li><li>地址的大小与编译器有关</li><li>内存地址本质上是一个无符号整数</li></ul></li><li><p>指针变量：保存地址的变量</p><ul><li>普通变量放的是值</li><li>禁止将普通数值当作地址赋值给指针变量，除非你知道自己在干什么</li></ul></li><li><p>指针定义：<code>&lt;type> *p;</code>或者<code>&lt;type>* p;</code></p><ul><li><p><code>&lt;type></code>决定<strong>访问内存时的长度范围</strong></p><blockquote><p>个人理解，指针类型也是个数据类型</p></blockquote></li></ul></li><li><p>访问指针地址上的变量：<code>*p</code></p><ul><li>可以做右值也可以做左值</li><li>没有赋值前不要访问</li></ul></li><li><p>指针应用场景</p><ul><li>交换变量</li><li>函数返回多个值，某些值就只能通过指针返回<ul><li>传入的参数实际上是需要保存结果的变量的地址</li></ul></li><li>函数返回运算的状态<code>(0, 1)</code>，结果通过指针返回<ul><li>可能会出错的运算</li><li>后续语言（<code>C++</code>，<code>Java</code>）采用了异常机制来解决这个问题</li></ul></li></ul></li><li><p>指针与数组</p><ul><li><p>函数参数表中的数组实际上是指针，但是可以用数组的运算符<code>[]</code>进行计算，不再含有数组长度信息</p></li><li><p><code>void func(int a[]);</code>和<code>void func(int* a);</code>作为函数原型是等价的</p></li><li><p><strong>数组类型和指针类型不是等价的</strong></p></li><li><p><code>[]</code>运算符可以对数组做，也可以对指针做</p></li><li><p><code>*</code>运算符可以对指针做，也可以对数组做</p></li><li><p><code>array</code>, <code>&array</code>, <code>&array[0]</code>区别</p><ul><li><p><code>array</code>可以<strong>当作</strong>一个<strong>指针常量</strong>，指向<strong>数组第一个元素</strong></p><ul><li>两种情况数组名不是用指针常量来表示<ol><li><code>sizeof(array)</code>：返回整个数组的长度，而不是指针的长度</li><li><code>&array</code>：返回一个指向数组的指针，而不是一个指向指针的指针</li></ol></li></ul></li><li><p><code>&array</code>是一个<strong>指针值</strong>，指向<strong>整个数组</strong></p></li><li><p><code>&array[0]</code>是一个<strong>指针值</strong>，指向<strong>数组的第一个元素</strong></p></li><li><p>三者值相同，但意义不同</p><blockquote><p><a href=https://blog.csdn.net/jingzi123456789/article/details/66478310>这是一个很好的解释</a></p></blockquote></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>array</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>)[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>array</span><span class=p>;</span>	<span class=c1>// pointer to whole array
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// ERROR
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Because array is a const pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// array = 5345454;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;        array = %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>array</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;       &amp;array = %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>array</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;    &amp;array[0] = %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>array</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;    array + 1 = %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>array</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;&amp;array[0] + 1 = %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>array</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;   &amp;array + 1 = %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>array</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34; sizeof(array) = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>array</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;sizeof(&amp;array) = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>&amp;</span><span class=n>array</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>Output</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>array</span> <span class=o>=</span> <span class=mf>0061F</span><span class=n>EEC</span>
</span></span><span class=line><span class=cl>       <span class=o>&amp;</span><span class=n>array</span> <span class=o>=</span> <span class=mf>0061F</span><span class=n>EEC</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;</span><span class=n>array</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mf>0061F</span><span class=n>EEC</span>
</span></span><span class=line><span class=cl>    <span class=n>array</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>=</span> <span class=mf>0061F</span><span class=n>EF0</span>
</span></span><span class=line><span class=cl><span class=o>&amp;</span><span class=n>array</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>=</span> <span class=mf>0061F</span><span class=n>EF0</span>
</span></span><span class=line><span class=cl>   <span class=o>&amp;</span><span class=n>array</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>=</span> <span class=mf>0061FF</span><span class=mo>00</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>sizeof</span><span class=p>(</span><span class=n>array</span><span class=p>)</span> <span class=o>=</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl><span class=k>sizeof</span><span class=p>(</span><span class=o>&amp;</span><span class=n>array</span><span class=p>)</span> <span class=o>=</span> <span class=mi>4</span>
</span></span></code></pre></div></li></ul></li><li><p>指针与<code>const</code></p><ul><li>指针是<code>const</code>：<ul><li><code>&lt;type>* const p;</code></li><li>该指针变量一旦得到了地址值，不能再指向其他变量</li></ul></li><li>指针所指的是<code>const</code>：<ul><li><code>&lt;type> const* p;</code>，<code>const &lt;type>* p;</code></li><li>表示不能通过这个指针去修改指向的变量，<strong>并不能</strong>使得那个变量成为<code>const</code></li></ul></li><li>总是可以把一个非<code>const</code>的值转换成<code>const</code><ul><li>当要传递的参数类型比地址大的时候，这是一种常用的手段：既能用较少的字节数传递值给参数，又能避免函数修改外面的变量</li></ul></li></ul></li><li><p>指针运算</p><ul><li><p>给指针加，减一个整数</p><ul><li><strong>偏移量</strong></li><li><code>p + n -> (unsigned int) p + n * sizeof(*p)</code></li><li>如果指针不是指向一片连续分配的空间，如数组，则这种计算没有意义</li></ul></li><li><p>递增递减</p></li><li><p>两个指针相减</p><ul><li>结果也是偏移量</li></ul></li><li><p><code>*p++</code></p><ul><li><p>取出<code>p</code>所指的数据，然后把<code>p</code>移到下一个位置去</p></li><li><p><code>*</code>的优先级低于<code>++ --</code></p></li><li><p>常用于数组类的连续空间操作</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>array</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>array</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=o>*</span><span class=n>p</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>p</span><span class=o>++</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p>在某些CPU上，这可以直接被翻译成一条汇编指令</p></li></ul></li><li><p>比较</p></li></ul></li><li><p>0地址</p><ul><li>所有程序都有0地址，通常不能随意读写</li><li><code>NULL</code>是一个预定义的符号，表示0地址</li><li>可以用0地址来表示特殊的事情<ul><li>返回的指针是无效的</li><li>指针没有被真正初始化（<strong>先初始化为0</strong>）</li></ul></li></ul></li><li><p>指针的类型转换</p><ul><li><code>void*</code>表示不知道指向什么的指针<ul><li>不能访问数据</li><li>计算与<code>char*</code>相同（不相通）</li><li>往往用在底层程序中</li></ul></li><li><code>(&lt;type>*) identifier;</code></li><li>并不改变指向变量的类型</li></ul></li><li><p>动态内存分配</p><ul><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;*</span> <span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=n>n</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// statement
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 动态分配内存的基本操作架构
</span></span></span></code></pre></div></li><li><p><code>C99</code>可以直接用变量定义数组大小</p></li><li><p><code>void* malloc(size_t size);</code></p><ul><li>申请的空间大小是以字节为单位的</li><li>需要自己将返回结果转换成自己需要的类型</li><li>申请失败返回<code>0(NULL)</code></li></ul></li><li><p><code>free()</code></p><ul><li>把申请的来的空间还给系统</li><li>只能还<strong>申请</strong>来的空间的<strong>首地址</strong></li><li><code>free(NULL)</code>不会出错</li></ul></li></ul></li><li><p>指针与函数</p><ul><li><p>函数名就是函数体代码的起始地址</p></li><li><p>通过函数名调用函数，本质为指定具体地址的跳转执行</p></li><li><p>可以定义指针保存函数入口地址</p></li><li><p><code>&lt;type> (*pFunc)(&lt;type1>, &lt;type2>) = func;</code></p></li><li><p><code>&func</code>和<code>func</code>数值相同，意义相同</p></li><li><p>调用函数：<code>pFunc(par);</code>或<code>*pFunc(par);</code></p></li><li><p>不能进行指针运算</p></li><li><p>应用：</p><ul><li>让程序跳转到固定地址执行，多用于嵌入式开发</li><li>回调函数（监听器模式的基础）<ul><li>调用者<strong>不知道</strong>具体事件发生时需要的调用函数</li><li>被调函数<strong>不知道</strong>何时被调用，只知道需要完成的任务</li><li>当具体时间发生时，调用者通过函数指针调用具体函数</li><li>回调机制中调用者和被调函数<strong>互不依赖</strong></li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>int</span><span class=p>(</span><span class=o>*</span><span class=n>Weapon</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fight</span><span class=p>(</span><span class=n>Weapon</span> <span class=n>wp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Fight boss!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>wp</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Boss loss: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>knife</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Knife attack: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sword</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Sword attack: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>+=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>gun</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Gun attack: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span> <span class=o>+=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fight</span><span class=p>(</span><span class=n>knife</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fight</span><span class=p>(</span><span class=n>sword</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fight</span><span class=p>(</span><span class=n>gun</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p>返回指针的函数</p><ul><li>返回本地变量的地址是危险的</li><li>返回全局变量或静态本地变量的地址是安全的</li><li>返回在函数内<code>malloc</code>的内存是安全的，但是容易造成问题</li><li>最好的做法是返回传入的指针</li></ul></li></ul></li><li><p>数组参数退化</p><table><thead><tr><th>数组参数</th><th>等效的指针参数</th></tr></thead><tbody><tr><td><code>&lt;type> a[size]</code></td><td><code>&lt;type>* a</code></td></tr><tr><td><code>&lt;type>* a[size]</code></td><td><code>&lt;type>** a</code></td></tr><tr><td><code>&lt;type> a[m][n]</code></td><td><code>&lt;type> (*a)[n]</code></td></tr></tbody></table></li></ul><hr><h2 id=字符数组和字符串>字符数组和字符串<a hidden class=anchor aria-hidden=true href=#字符数组和字符串>#</a></h2><ul><li>字符数组：<code>char word[] = {'H', 'E', 'L', 'L', 'O'};</code></li></ul><h3 id=字符串>字符串<a hidden class=anchor aria-hidden=true href=#字符串>#</a></h3><ul><li><p>C语言实际上没有字符串概念，用字符数组模拟</p></li><li><p><code>char word[] = {'H', 'E', 'L', 'L', 'O', '\0'};</code></p></li><li><p>以<code>0</code>（整数0）结尾的一串字符</p></li><li><p><code>0</code>或<code>\0</code>是一样的（字节大小不同，4：1），但是和<code>'0'</code>不同</p></li><li><p><code>0</code>表示字符串的结束，但它不是字符串的一部分，计算长度时不包含这个<code>0</code></p></li><li><p>字符串以数组形式存在，以数组或指针的形式访问，更多的是以指针的形式</p></li><li><p><code>string.h</code></p></li><li><p>字符串常量（字面量）</p><ul><li><code>"string"</code></li><li>会被编译器变成一个字符数组放在<strong>全局只读代码段</strong>，数组长度是<code>字符个数+1</code>，结尾有表示结束的<code>0</code></li><li>两个相邻的字符串常量会连接起来</li><li>可以当作常量指针</li></ul></li><li><p>字符串变量</p><ul><li><code>char* str = "Hello";</code><ul><li><code>str</code>是一个指针，初始化为指向一个字符串常量</li><li>因为字符串常量不能被修改，所以实际上<code>str</code>是<code>const char*</code>类型</li><li>历史原因，编译器接受不带<code>const</code>的写法</li><li>试图对<code>str</code>所指的字符串做写入会导致程序崩溃</li></ul></li><li><code>char word[] = "Hello";</code><ul><li>定义为数组类型可以修改内部的字符串</li><li>实际上编译器隐式地将字符串常量拷贝到定义的数组空间</li></ul></li><li>指针还是数组？<ul><li><strong>构造</strong>字符串：数组</li><li><strong>处理</strong>字符串：指针</li></ul></li><li><code>char line[10] = "Hello";</code></li></ul></li><li><p>字符串赋值：<code>char* str1 = "hello"; char* str2 = str1;</code></p><ul><li>并没有产生新的字符串，只是让<code>str2</code>指向了<code>str1</code>所指的字符串</li></ul></li><li><p>字符串输入输出：<code>%s</code></p><ul><li><code>scanf</code>读入一个单词（到空格，tab或回车为止）</li><li><code>scanf</code>是不安全的，因为不知道要读入的内容的长度</li><li><code>%7s</code>：安全的输入，数字表示最多允许读入的字符数量。如果输入的长度超过指定长度，下一次的<code>scanf</code>会在上一次读入的终点接着读</li></ul></li><li><p>空字符串</p><ul><li>只有一个<code>\0</code>的字符串</li><li><code>char buffer[100] = "";</code><ul><li>一个空字符串，<code>buffer[0] == '\0'</code></li></ul></li><li><code>char buffer[] = "";</code><ul><li>这个数组长度只有1</li></ul></li></ul></li><li><p>字符串数组</p><ul><li><p><code>char** a</code></p><ul><li><code>a</code>是一个指针，指向另一个指针，那个指针指向一个字符（串）</li><li>也可以<strong>看成</strong>一个指针数组，前提访问合法</li></ul></li><li><p><code>char a[][size]</code></p><ul><li>可以表示一个字符串数组，但是里面的字符串大小有限制</li></ul></li><li><p><code>char* a[]</code></p><ul><li><p>也可以表示一个字符串数组，里面是一个个指向字符串的指针</p></li><li><p><code>&lt;type> (*p1)[size]</code>和<code>&lt;type>* p2[size]</code>的区别</p><blockquote><p><a href=https://www.geeksforgeeks.org/difference-between-int-p3-and-int-p3/>一个很好的解释</a></p><p>一个是指向整个数组的指针，一个是数据元素是指针的数组</p><p><code>*p1</code>返回的是指向的数组的首地址</p><p><code>*p2</code>返回的是指针数组里第一个指针元素的值</p></blockquote></li></ul></li></ul></li><li><p>程序参数</p><ul><li><code>int main(int argc, char const *argv[])</code></li><li><code>argv[0]</code>是命令本身，当使用<code>Unix</code>的符号链接时，反应符号链接的名字</li></ul></li><li><p><code>putchar</code></p><ul><li><code>int putchar(int c);</code></li><li>向标准输出写一个字符</li><li>返回写了几个字符，<code>EOF(-1)</code>表示写失败</li></ul></li><li><p><code>getchar</code></p><ul><li><code>int getchar(void);</code></li><li>从标准输入读入一个字符</li><li>返回读到的字符</li><li>返回<code>EOF</code><ul><li>Windows：<code>Ctrl + Z</code></li><li>Unix：<code>Ctrl + D</code></li></ul></li><li><code>shell</code>进行行编辑，然后程序从缓冲区读入数据</li></ul></li><li><p>字符串函数</p><ul><li><p><code>strlen</code></p><ul><li><code>size_t strlen(const char *s);</code></li><li>返回字符串的长度</li></ul></li><li><p><code>strcmp</code></p><ul><li><code>int strcmp(const char *s1, const char *s2);</code></li><li>比较两个字符串，返回：<ul><li><code>0</code>：<code>s1 == s2</code></li><li><code>s1[idx] - s2[idx]</code>：<code>s1 != s2</code>，<code>idx</code>是第一个不相等字符的下标</li></ul></li></ul></li><li><p><code>strcpy</code></p><ul><li><p><code>char* strcpy(char* restrict dst, const char* restrict src);</code></p></li><li><p>把<code>src</code>的字符串拷贝到<code>dst</code>，返回<code>dst</code></p></li><li><p><code>restrict</code>关键字：表明不重叠（<code>C99</code>）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>dst</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=n>strlen</span><span class=p>(</span><span class=n>src</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>strcpy</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span> <span class=n>src</span><span class=p>);</span>
</span></span></code></pre></div></li></ul></li><li><p><code>strcat</code></p><ul><li><code>char* strcat(char* restrict s1, const char* restrict s2);</code></li><li>把<code>s2</code>拷贝到<code>s1</code>的后面，接成一个长的字符串，返回<code>s1</code></li><li><code>s1</code>必须有足够的空间</li></ul></li><li><p><code>strcpy</code>和<code>strcat</code>都可能出现安全问题，即目标没有足够的空间。尽可能不要使用这两个函数</p></li><li><p>安全版本</p><ul><li><code>char* strncpy(char* restrict dst, const char* restrict src, size_t n);</code></li><li><code>char* strncat(char* restrict s1, const char* restrict s2, size_t n);</code></li></ul></li><li><p><code>strncmp</code></p><ul><li><code>int strncmp(const char *s1, const char *s2, size_t n);</code></li><li>比较前n个字符</li></ul></li><li><p><code>strchr</code>，<code>strrchr</code></p><ul><li><p>字符串中找字符，一个从左开始，一个从右开始</p></li><li><p><code>char* strchr(const char* s, int c);</code></p></li><li><p><code>char* strrchr(const char* s, int c);</code></p></li><li><p>返回指针，返回<code>NULL</code>表示没有找到</p></li><li><p>找第二个</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>s</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>strchr</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>strchr</span><span class=p>(</span><span class=n>p</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>);</span>
</span></span></code></pre></div></li><li><p>找到后拷贝</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>s</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>strchr</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 拷贝后一段
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>t</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=n>strlen</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>strcpy</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 拷贝前一段
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>t</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>strcpy</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul></li><li><p><code>strstr</code>，<code>strcasestr</code></p><ul><li>字符串中找字符串，<code>strcasestr</code>忽略大小写</li><li><code>char* strstr(const char* s1, const char* s2);</code></li><li><code>char* strcasestr(const char* s1, const char* s2);</code></li></ul></li><li><p><code>strtok</code></p></li></ul></li></ul><hr><h2 id=枚举>枚举<a hidden class=anchor aria-hidden=true href=#枚举>#</a></h2><ul><li>常量符号化：<code>const</code></li><li>枚举是一种用户定义的数据类型，意义是给一些可以排列起来的常量值名字</li><li><code>enum typeName {name 1, name 2, ..., name n};</code></li><li>枚举类型本质上是<strong>整型</strong></li><li>声明枚举量可以指定值</li><li>枚举类型名字通常并不真的使用，要用的是大括号里的名字，因为它们就是常量符号，类型是<code>int</code>，值则依次从<code>0</code>到<code>n</code></li><li>类型名字可以省略</li><li>定义枚举变量：<code>enum typeName var = name 1;</code></li><li>枚举变量本质上是<strong>整型变量</strong></li><li>套路：自动计数的枚举 <code>enum COLOR {RED, YELLOW, GREEN, NumCOLORS};</code></li><li>虽然枚举可以当作类型使用，但实际上很少用</li><li>如果有意义上排比的名字，用枚举比<code>const int</code>方便</li><li>枚举比宏好，因为枚举量有<code>int</code>类型</li></ul><hr><h2 id=自定义数据类型>自定义数据类型<a hidden class=anchor aria-hidden=true href=#自定义数据类型>#</a></h2><h3 id=结构体>结构体<a hidden class=anchor aria-hidden=true href=#结构体>#</a></h3><ul><li><p>结构体变量的本质是变量的集合</p></li><li><p>结构体变量中的成员占用独立的内存</p></li><li><p>结构类型声明，定义结构体变量，访问成员变量，初始化</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// First form
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=o>&lt;</span><span class=n>yourType</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;</span> <span class=n>var1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;</span> <span class=n>var2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;</span> <span class=n>var3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=o>&lt;</span><span class=n>yourType</span><span class=o>&gt;</span> <span class=n>yourVar</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Second form
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;</span> <span class=n>var1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;</span> <span class=n>var2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;</span> <span class=n>var3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>yourVar1</span><span class=p>,</span> <span class=n>yourVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Third form
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=o>&lt;</span><span class=n>yourType</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;</span> <span class=n>var1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;</span> <span class=n>var2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;</span> <span class=n>var3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>yourVar1</span><span class=p>,</span> <span class=n>yourVar2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// access
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>yourVar</span><span class=p>.</span><span class=n>var1</span> <span class=o>=</span> <span class=o>&lt;</span><span class=n>value</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Initialisation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=o>&lt;</span><span class=n>yourType</span><span class=o>&gt;</span> <span class=n>yourVar1</span> <span class=o>=</span> <span class=p>{</span><span class=o>&lt;</span><span class=n>value1</span><span class=o>&gt;</span><span class=p>,</span> <span class=o>&lt;</span><span class=n>value2</span><span class=o>&gt;</span><span class=p>,</span> <span class=o>&lt;</span><span class=n>value3</span><span class=o>&gt;</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=o>&lt;</span><span class=n>yourType</span><span class=o>&gt;</span> <span class=n>yourVar1</span> <span class=o>=</span> <span class=p>{.</span><span class=n>var1</span> <span class=o>=</span> <span class=o>&lt;</span><span class=n>value1</span><span class=o>&gt;</span><span class=p>,</span> <span class=p>.</span><span class=n>var2</span> <span class=o>=</span> <span class=o>&lt;</span><span class=n>value2</span><span class=o>&gt;</span><span class=p>};</span>	<span class=c1>// yourVar1.var3 == 0
</span></span></span></code></pre></div><ul><li>在函数内部声明的结构类型只能在函数内部使用</li><li>通常在函数外部声明结构类型</li><li>不同无名结构体变量，尽管内部成员变量类型都相同，也不是同一数据类型</li></ul></li><li><p>结构运算</p><ul><li>访问整个结构</li><li>赋值<ul><li><code>struct &lt;type> var; var = (struct &lt;type>){&lt;value>, };</code></li><li><code>var1 = var2;</code></li></ul></li><li>取地址<ul><li>结构变量的名字并不是结构变量的地址，必须使用<code>&</code>运算符</li><li><code>struct &lt;type>* pVar = &amp;var;</code></li><li>用指针变量访问结构成员：<code>(*p).var</code>或者**<code>p->var</code>**</li><li><code>.</code>，<code>-></code>优先级高于<code>&</code></li></ul></li><li>传给函数参数</li></ul></li><li><p>结构与函数</p><ul><li>整个结构作为参数的值传入函数</li><li>函数内新建一个结构变量，复制调用结构变量的值</li><li>可以返回一个结构</li></ul></li><li><p>输入结构</p><ul><li>没有直接的方式可以一次<code>scanf</code>一个结构</li><li>可以自己写一个函数<ul><li><code>struct &lt;type> getStruct(void);</code></li><li><code>struct &lt;type>* getStruct(struct &lt;type>* p);</code><ul><li>返回传进来的指针的好处是可以把程序连起来</li></ul></li></ul></li></ul></li><li><p>结构数组</p></li><li><p>结构中的结构</p></li><li><p>位域：利用结构体类型指定成员变量占用内存的比特位宽度</p><ul><li>某些特殊场合，远古代码中可能被使用</li><li>位域成员必须是整型，占用位数不能超过类型宽度</li><li>当存储位不足时，自动启用新存储单元</li><li>可以舍弃当前未使用的位，重新启用存储单元</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>BW</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=nl>a</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span>	<span class=c1>// a 占用一个字节的4位宽度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=nl>b</span> <span class=p>:</span> <span class=mi>5</span><span class=p>;</span>	<span class=c1>// b 占用一个字节的5位宽度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>char</span>   <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>	<span class=c1>// 重启一个存储单元表示新的成员
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=nl>c</span> <span class=p>:</span> <span class=mi>2</span><span class=p>;</span>	<span class=c1>// c 占用一个字节的2位宽度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div></li></ul><h3 id=typedef><code>typedef</code><a hidden class=anchor aria-hidden=true href=#typedef>#</a></h3><ul><li><p>声明一个已有数据类型的新名字</p></li><li><p>没有创建新类型，只是创建了类型别名</p></li><li><p><code>typedef &lt;type> &lt;newTypeName>;</code></p></li><li><p>改善了程序的可读性</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// typedef basic data type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>byte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// typedef function type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>pFunc</span><span class=p>)(</span><span class=kt>int</span><span class=p>)</span> <span class=o>=</span> <span class=n>func</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>int</span><span class=p>(</span><span class=n>IFuncI</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>IFuncI</span><span class=o>*</span> <span class=n>pFunc</span> <span class=o>=</span> <span class=n>func</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// typedef array type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>float</span> <span class=n>array</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=p>(</span><span class=o>*</span><span class=n>pArray</span><span class=p>)[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>array</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>float</span><span class=p>(</span><span class=n>FArr5</span><span class=p>)[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>FArr5</span><span class=o>*</span> <span class=n>pArray</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>array</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// typedef struct type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Node</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Node</span> <span class=n>aNode</span> <span class=o>=</span> <span class=p>{</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>};</span>	<span class=c1>// rather than struct Node aNode;
</span></span></span></code></pre></div></li></ul><h3 id=联合>联合<a hidden class=anchor aria-hidden=true href=#联合>#</a></h3><ul><li><p><code>union</code></p></li><li><p>语法上和<code>struct</code>一样</p></li><li><p><code>sizeof(union &lt;name>) == sizeof(每个成员)的最大值</code></p></li><li><p>所有成员共享一个空间</p></li><li><p>同一时间只有一个成员是有效的</p></li><li><p><code>union</code>类型的变量只能以第一个成员类型的有效值进行初始化</p></li><li><p>应用</p><ul><li><p>判断系统大小端</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>isLittleEndian</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>a</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=n>test</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>test</span><span class=p>.</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>test</span><span class=p>.</span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul></li></ul><hr><h2 id=宏>宏<a hidden class=anchor aria-hidden=true href=#宏>#</a></h2><ul><li><p>编译预处理指令：<code>#</code>开头</p></li><li><p>预处理指令不是C语言的成分</p></li><li><p>宏定义：<code>#define &lt;name> &lt;value></code></p></li><li><p>没有<code>;</code>因为不是C语句</p></li><li><p>名字必须是单词，值可以是各种东西</p></li><li><p>在C语言的编译器开始编译之前，编译预处理程序（The C Preprocessor）会把程序中的名字换成值</p></li><li><p>预处理宏：<strong>简单的文本替换</strong></p></li><li><p>预处理器不会对宏定义进行语法检查</p></li><li><p>如果一个宏的值中有其他宏的名字，也会被替换</p></li><li><p>如果一个宏的值超过一行，最后一行之前的行末需要加<code>\</code></p></li><li><p>宏的值后面出现的注释不会被当作宏的值的一部分</p></li><li><p>宏定义之后，后面代码可以随意使用，<strong>没有作用域的概念</strong></p></li><li><p>没有值的宏</p><ul><li>例：<code>#define _DEBUG</code></li><li>这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了</li><li>定义宏编译指令：<code>gcc -DMACRO=1 file.c</code></li></ul></li><li><p>预定义的宏</p><ul><li><code>__LINE__</code>：当前所在行的行号</li><li><code>__FILE__</code>：源代码文件的文件名</li><li><code>__DATE__</code>：编译时的日期</li><li><code>__TIME__</code>：编译时的时间</li><li><code>__STDC__</code>：编译器是否遵循标准C规范，值为<code>1</code>或<code>0</code></li></ul></li><li><p>带参数的宏</p><ul><li>类似函数的宏</li><li><code>()</code>的原则<ul><li>一切都要带括号</li><li>整个值要括号</li><li>参数出现的地方要括号</li></ul></li><li>宏表达式中不能出现递归定义</li></ul></li><li><p>宏和函数</p><ul><li><p>宏是由预处理器直接替换展开的，编译器不知道宏的存在，所以不安全</p><p>函数是由编译器直接编译的实体，调用行为由编译器决定</p></li><li><p>多次使用宏会导致最终可执行程序的体积增大</p><p>函数是跳转执行的，内存中只有一份函数体存在</p></li><li><p>宏的效率比函数要高，因为直接展开，无调用开销</p><p>函数调用时会创建活动记录，效率不如宏</p></li><li><p>使用原则</p><ul><li><p>能用函数实现的使用函数</p></li><li><p>宏可以用于生成一些常规性的代码；封装函数，加上类型信息</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 函数封装
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define MALLOC(type, x)   (type*)malloc(sizeof(type) * x)
</span></span></span><span class=line><span class=cl><span class=cp>#define FREE(p)           (free(p), p = NULL)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define LOG_INT(i)     printf(&#34;%s = %d\n&#34;, #i, i)
</span></span></span><span class=line><span class=cl><span class=cp>#define LOG_CHAR(c)    printf(&#34;%s = %c\n&#34;, #c, c)
</span></span></span><span class=line><span class=cl><span class=cp>#define LOG_STRING(s)  printf(&#34;%s = %s\n&#34;, #s, s)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define FOREACH(i, n)	 for(int i = 0; i &lt; n; i++)
</span></span></span><span class=line><span class=cl><span class=cp>#define BEGIN			{
</span></span></span><span class=line><span class=cl><span class=cp>#define END				}
</span></span></span></code></pre></div></li></ul></li></ul></li></ul><hr><h2 id=多文件程序设计>多文件程序设计<a hidden class=anchor aria-hidden=true href=#多文件程序设计>#</a></h2><ul><li><p>一个源代码文件太长了适合分成几个文件</p></li><li><p>工程项目 -> 功能X，Y，Z&mldr;</p></li><li><p>编译和链接</p><ul><li><p>一个<code>.c</code>文件是一个编译单元</p></li><li><p>编译器每次编译只处理一个编译单元</p></li><li><p>编译完形成<code>.o</code>文件，目标代码文件</p><blockquote><p>A file ending in .o is an <em>object file</em>. The compiler creates an object file for each source file, before linking them together, into the final executable.</p></blockquote></li><li><p>多个<code>.o</code>文件链接起来得到可执行文件<code>.exe</code></p></li></ul></li><li><p>文件可以定义为功能接口（可被其他文件的函数或数据）</p><ul><li>源文件：<strong>代码实现</strong>文件，<code>.c</code><ul><li>标准库的函数代码实现在某个<code>.lib</code>（Windows）或<code>.a</code>（Unix）中</li></ul></li><li>头文件：源文件的<strong>接口</strong>定义文件，<code>.h</code></li></ul></li><li><p>声明和定义</p><ul><li>声明是不产生代码的东西，意义是告诉编译器程序单元的存在<ul><li>C语言中通过<code>extern</code>进行程序单元的声明，一些程序单元可以省略该关键字</li><li>函数原型</li><li>变量声明</li><li>结构声明</li><li>宏声明</li><li>枚举声明</li><li>类型声明</li><li><code>inline</code>函数</li></ul></li><li>定义是产生代码的东西，意义是指示程序单元的意义</li></ul></li><li><p>头文件<code>.h</code></p><ul><li>存放声明<ul><li>规矩上，只有声明可以被放在头文件中</li><li>如果放定义，会造成一个项目中多个编译单元里有重名的实体</li><li>某些编译器允许几个编译单元中存在同名函数，或者用<code>weak</code>修饰符来强调这种存在</li></ul></li><li>在需要调用头文件中的函数的源代码文件<code>.c</code>中<code>#include</code>这个头文件，就能让编译器在编译的时候知道这个函数的原型，<strong>保证你调用时给出的参数值和返回值是正确的类型</strong></li><li><code>#include</code>是一个编译预处理指令，会把那个文件的全部文本内容<strong>原封不动</strong>地插入到他所在的地方</li><li><code>#include</code>的两种形式<ul><li><code>""</code>：要求编译器首先在当前目录中（<code>.c</code>文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找</li><li><code>&lt;></code>：让编译器只在指定的目录去找</li></ul></li><li>编译器自己知道自己的标准库的头文件在哪里，环境变量和编译器命令行参数也可以指定寻找头文件的目录</li><li>现在的C语言编译器默认会引入所有的标准库</li><li>在使用和定义函数的地方都应该<code>#include</code>这个头文件<ul><li>使用：编译器可以检查函数调用的正确性</li><li>定义：编译器可以检查对外宣称的函数原型和实际定义是否一致</li><li>一般的做法是任何的<code>.c</code>都有对应的同名<code>.h</code>（<code>main.c</code>除外），把所有对外公开的函数的原型和全局变量的声明都放进去</li></ul></li><li>不对外公开的函数：<code>static</code>修饰，使得该函数只能在所在的编译单元中被使用</li><li>静态全局变量<code>static</code>修饰，使得它成为只能在所在的编译单元中被使用的全局变量</li><li>普通全局变量的<strong>声明</strong>：<code>extern &lt;type> &lt;identifier>;</code></li></ul></li><li><p>标准头文件结构</p><ul><li><p>重复声明问题</p><ul><li>同一个编译单元里，同名的结构不能被重复声明</li><li>如果你的头文件里有结构的声明，很难让这个头文件不会在一个编译单元里被<code>#include</code>多次</li><li>所以需要<strong>标准头文件结构</strong></li></ul></li><li><p>运用条件编译和宏，保证这个头文件在一个编译单元中只会被<code>#include</code>一次</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-h data-lang=h><span class=line><span class=cl><span class=cp>#ifndef _LIST_H_
</span></span></span><span class=line><span class=cl><span class=cp>#define _LIST_H_
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;node.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_list</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div></li><li><p><code>#progma once</code>也能起到相同的作用，但不是所有的编译器都支持</p></li></ul></li></ul><hr><h2 id=简论编译和链接>简论编译和链接<a hidden class=anchor aria-hidden=true href=#简论编译和链接>#</a></h2><ul><li><p>编译器（广义）</p><ul><li><p>预处理器</p></li><li><p>编译器</p></li><li><p>汇编器</p></li><li><p>链接器</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph LR;
A((file.c))
B((file.h))
C(预处理器)
A --&gt; C
B --&gt; C
D((file.i))
E(编译器)
C --&gt; D
D --&gt; E
F((file.s))
G(汇编器)
E --&gt; F
F --&gt; G
H((file.o))
G --&gt; H
</code></pre></li></ul></li><li><p>预编译</p><ul><li>生成中间文件<code>.i</code></li><li>处理所有的注释，以空格代替</li><li>将所有的<code>#define</code>删除，并且展开所有的宏定义</li><li>处理条件编译指令<code>#if, #ifdef, #elif, #else, #endif</code></li><li>处理<code>#include</code>，展开被包含的文件</li><li>保留编译器需要使用的<code>#pragma</code>指令</li><li>预处理指令：<code>gcc -E file.c -o file.i</code></li></ul></li><li><p>编译</p><ul><li>对预处理文件进行词法分析，语法分析和语义分析<ul><li>词法分析：分析关键字，标识符，立即数等是否合法</li><li>语法分析：分析表达式是否遵循语法规则</li><li>语义分析：在语法分析的基础上进一步分析表达式是否合法</li></ul></li><li>分析结束后进行代码优化生成相应的汇编代码文件</li><li>编译指令：<code>gcc -S file.c -o file.s</code></li></ul></li><li><p>汇编</p><ul><li>汇编器将汇编代码转变为机器的可执行指令</li><li>生成机器代码目标文件<code>.o</code></li><li>汇编指令：<code>gcc -c file.s -o file.o</code></li></ul></li><li><p>链接</p><ul><li><p>链接器的主要作用是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确的衔接</p></li><li><p>静态链接：链接器在链接时将库的内容直接加入到可执行程序中，执行时与原来的那些文件没有关系</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TB;
A((file1.o))
B((file2.o))
C((libc.a))
D(链接器)
E((a.out))
A --&gt; D
B --&gt; D
C --&gt; D
D --&gt; E
</code></pre><ul><li><code>Linux</code>下静态库的创建和使用<ul><li>编译静态库源码：<code>gcc -c lib.c -o lib.o</code></li><li>生成静态库文件：<code>ar -q lib.a lib.o</code></li><li>使用静态库编译：<code>gcc main.c lib.a -o main.out</code></li></ul></li></ul></li><li><p>动态链接：可执行程序在运行时才动态加载库进行链接，库的内容不会进入可执行程序当中</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph LR;
A((lib1.so))
B((lib2.so))
C[stub1]
D[stub2]
E(链接器)
F((a.out))
A --- C
B --- D
C --&gt; E
D --&gt; E
E --&gt; F
</code></pre><ul><li><code>Linux</code>下动态库的创建和使用<ul><li>编译动态库源码：<code>gcc -shared dlib.c -o dlib.so</code></li><li>使用动态库编译：<code>gcc main.c -lbl -o main.out</code></li><li>关键系统调用：<ul><li><code>dlopen</code>：打开动态库文件</li><li><code>dlsym</code>：查找动态库中的函数并返回调用地址</li><li><code>dlclose</code>：关闭动态库文件</li></ul></li></ul></li></ul></li></ul></li><li><p>条件编译</p><ul><li><p>条件编译是<strong>预编译</strong>指示命令，用于控制是否编译某段代码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#if (C == 1)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>#ifdef C
</span></span></span><span class=line><span class=cl><span class=cm>#ifndef C
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>	<span class=c1>// statements
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=c1>//statements
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#endif
</span></span></span></code></pre></div></li><li><p>实际工程中条件编译主要用于以下两种情况：</p><ul><li>不同产品线共用一份代码</li><li>区分编译产品的调试版和发布版</li></ul></li></ul></li><li><p><code>#error</code>，<code>#warning</code></p><ul><li><p>用于生成一个自定义的编译错误消息/警告</p></li><li><p>用法：<code>#error message</code>，<code>message</code>不需要双引号</p></li><li><p>是一个预编译器指示字</p></li><li><p>可用于提示编译条件是否满足</p><p>例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifndef __cplusplus
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=cp>#error This file should be processed with C++ compiler.
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div></li><li><p>编译过程中的任意错误信息意味着无法生成最终的可执行程序</p></li></ul></li><li><p><code>#pragma</code></p><ul><li><p>用于指示编译器完成一些特定的动作</p></li><li><p><code>#pragma</code>所定义的很多指示字是编译器特有的</p></li><li><p>在不同的编译器间是不可移植的</p><ul><li>预处理器将忽略它不认识的<code>#pragma</code>指令</li><li>不同的编译器可能以不同的方式解释同一条<code>#pragma</code>指令</li></ul></li><li><p>用法：<code>#pragma parameter</code></p><ul><li><code>#pragma message</code><ul><li><code>message</code>参数在大多数的编译器中都有相似的实现</li><li>在编译时输出消息到编译输出窗口中</li><li>可以用于条件编译中提示代码的版本信息</li></ul></li></ul></li></ul></li></ul><hr><h2 id=输入输出>输入输出<a hidden class=anchor aria-hidden=true href=#输入输出>#</a></h2><ul><li><p>格式化输入输出</p><ul><li><p><code>printf</code>：<code>%[flag][width][.prec][hIL]type</code></p><table><thead><tr><th><code>Flag</code></th><th>含义</th></tr></thead><tbody><tr><td><code>-</code></td><td>左对齐</td></tr><tr><td><code>+</code></td><td>在前面放<code>+</code>或<code>-</code></td></tr><tr><td><code>(space)</code></td><td>正数留空</td></tr><tr><td><code>0</code></td><td>0填充</td></tr></tbody></table><table><thead><tr><th><code>width</code>, <code>prec</code></th><th>含义</th></tr></thead><tbody><tr><td><code>number</code></td><td>最小字符数</td></tr><tr><td><code>*</code></td><td>指代参数是字符数</td></tr><tr><td><code>.number</code></td><td>小数点后的位数</td></tr><tr><td><code>.*</code></td><td>指代参数是小数点后的位数</td></tr></tbody></table><table><thead><tr><th><code>hIL</code></th><th>含义</th></tr></thead><tbody><tr><td><code>hh</code></td><td>单个字节</td></tr><tr><td><code>h</code></td><td><code>short</code></td></tr><tr><td><code>l</code></td><td><code>long</code></td></tr><tr><td><code>ll</code></td><td><code>long long</code></td></tr><tr><td><code>L</code></td><td><code>long double</code></td></tr></tbody></table><table><thead><tr><th><code>type</code></th><th>用于</th></tr></thead><tbody><tr><td><code>i / d</code></td><td>int</td></tr><tr><td><code>u / U</code></td><td>unsigned int</td></tr><tr><td><code>o / O</code></td><td>八进制</td></tr><tr><td><code>x</code></td><td>十六进制</td></tr><tr><td><code>X</code></td><td>字母大写的十六进制</td></tr><tr><td><code>f / F</code></td><td>float，6位</td></tr><tr><td><code>e / E</code></td><td>指数</td></tr><tr><td><code>g</code></td><td>float</td></tr><tr><td><code>G</code></td><td>float</td></tr><tr><td><code>a / A</code></td><td>十六进制浮点</td></tr><tr><td><code>c</code></td><td>char</td></tr><tr><td><code>s</code></td><td>字符串</td></tr><tr><td><code>p</code></td><td>指针</td></tr><tr><td><code>n</code></td><td>读入/写出的个数</td></tr></tbody></table></li><li><p><code>scanf</code>：<code>%[flag]type</code></p><table><thead><tr><th><code>Flag</code></th><th>含义</th></tr></thead><tbody><tr><td><code>*</code></td><td>跳过</td></tr><tr><td><code>number</code></td><td>读入最大字符数</td></tr><tr><td><code>hh</code></td><td><code>char</code></td></tr><tr><td><code>h</code></td><td><code>short</code></td></tr><tr><td><code>l</code></td><td><code>long, double</code></td></tr><tr><td><code>ll</code></td><td><code>long long</code></td></tr><tr><td><code>L</code></td><td><code>long double</code></td></tr></tbody></table><table><thead><tr><th><code>type</code></th><th>用于</th></tr></thead><tbody><tr><td><code>d</code></td><td><code>int</code></td></tr><tr><td><code>i</code></td><td><code>int</code>，可以接受十六进制或八进制</td></tr><tr><td><code>u</code></td><td><code>unsigned int</code></td></tr><tr><td><code>o</code></td><td>八进制</td></tr><tr><td><code>x</code></td><td>十六进制</td></tr><tr><td><code>a, e, f, g</code></td><td>float</td></tr><tr><td><code>c</code></td><td>char</td></tr><tr><td><code>s</code></td><td>字符串</td></tr><tr><td><code>[...]</code></td><td>所允许的字符</td></tr><tr><td><code>p</code></td><td>指针</td></tr></tbody></table></li><li><p><code>printf</code>返回输出的字符数，<code>scanf</code>返回读入的项目数</p></li></ul></li><li><p>文件输入输出</p><ul><li><p>程序运行重定向：<code>&lt;</code>， <code>></code></p></li><li><p><code>FILE</code></p><ul><li><p>标准库里声明的类型</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>FILE</span><span class=o>*</span> <span class=nf>fopen</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=kr>restrict</span> <span class=n>path</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=kr>restrict</span> <span class=n>mode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fclose</span><span class=p>(</span><span class=n>FILE</span><span class=o>*</span> <span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>fscanf</span><span class=p>(</span><span class=n>FILE</span><span class=o>*</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl><span class=n>fprintf</span><span class=p>(</span><span class=n>FILE</span><span class=o>*</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 打开文件的标准代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>FILE</span><span class=o>*</span> <span class=n>fp</span> <span class=o>=</span> <span class=n>fopen</span><span class=p>(</span><span class=s>&#34;file&#34;</span><span class=p>,</span> <span class=s>&#34;r&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>fp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fscanf</span><span class=p>(</span><span class=n>fp</span><span class=p>,</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl>    <span class=n>fclose</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	r:		打开只读
</span></span></span><span class=line><span class=cl><span class=cm>	r+:		打开读写，从文件头开始
</span></span></span><span class=line><span class=cl><span class=cm>	w:		打开只写。如果不存在则新建，如果存在则清空
</span></span></span><span class=line><span class=cl><span class=cm>	w+:		打开读写。如果不存在则新建，如果存在则清空
</span></span></span><span class=line><span class=cl><span class=cm>	a:		打开追加。如果不存在则新建，如果存在则从文件尾开始
</span></span></span><span class=line><span class=cl><span class=cm>	..x:	只新建，如果文件已存在则不能打开
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div></li></ul></li></ul></li><li><p>文本文件 vs 二进制文件</p><ul><li><p>本质上，所有文件都是二进制文件</p></li><li><p>文本文件无非是用最简单的方式可以读写的文件</p></li><li><p>二进制文件是需要专门的程序来读写的文件</p></li><li><p>文本文件的输入输出是格式化，可能经过转码</p></li><li><p><code>Unix</code>喜欢用文本文件来做数据存储和程序配置；<code>Windows</code>喜欢用二进制文件</p></li><li><p>文本的优点是方便人类读写，而且跨平台；缺点是输入输出要经过格式化，开销大</p><p>二进制的优点是程序读写快，缺点是人类读写困难，而且不跨平台</p></li><li><p>程序为什么要文件</p><ul><li>配置：<code>Unix</code>用文本，<code>Windows</code>用注册表</li><li>数据：稍微有点量的数据都放数据库了</li><li>媒体：只能是二进制</li></ul></li><li><p>现实是，程序通过第三方库来读写文件，很少直接读写二进制文件做底层操作</p></li></ul></li></ul><hr><h2 id=程序的基本数据区>程序的基本数据区<a hidden class=anchor aria-hidden=true href=#程序的基本数据区>#</a></h2><ul><li>栈<ul><li>用于维护函数调用上下文<ul><li>保存了参数，返回地址，<code>old ebp</code>，寄存器信息，局部变量，其他数据信息</li></ul></li><li>后进先出，栈底栈顶</li><li>每次函数调用都对应着栈上的一个活动记录<ul><li>调用函数的活动记录位于栈的中部</li><li>被调函数的活动记录位于栈的顶部</li></ul></li><li>函数调用时，对应的栈空间在函数返回前是专用的</li><li>函数调用结束后，栈空间将被释放，数据不再有效；在调用下一个函数前数据仍然存在</li></ul></li><li>堆<ul><li>堆是程序中一块预留的内存空间，可由程序自由使用</li><li>堆中被程序申请的内存在被主动释放前将一直有效</li><li>为什么有了栈还需要堆？<ul><li>栈上的数据在函数返回后就会被释放掉，无法传递到函数外部</li></ul></li><li>系统对堆空间的管理方式：空闲链表法，位图法，对象池法等</li></ul></li><li>静态存储区<ul><li>随着程序的运行而分配空间</li><li>生命周期直到程序运行结束</li><li>在程序的编译期静态存储区的大小就已经确定</li><li>主要用于保存全局变量和静态局部变量</li><li>静态存储区的信息最终会保存到可执行程序中</li></ul></li><li>程序的内存布局<ul><li>可执行文件的布局：<code>File Header | .text | .data | .bss</code></li><li>映射到进程的地址空间：<code>stack | heap | .bss | .data | .text | 未映射区域</code></li><li>堆栈段在程序运行后才正式存在</li><li><code>.bss</code>段存放的是未初始化的全局变量和静态变量</li><li><code>.text</code>段存放的是程序中的可执行代码</li><li><code>.data</code>段保存的是已经初始化了的全局变量和静态变量</li><li><code>.rodata</code>段存放程序中的常量值，如字符串常量</li><li>静态存储区通常指程序中的<code>.bss</code>和<code>.data</code>段</li><li>只读存储区通常指程序中的<code>.rodata</code>段</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://hadjshell.github.io/tags/%E5%88%80%E6%B3%95/>刀法</a></li><li><a href=https://hadjshell.github.io/tags/c/>C</a></li></ul><nav class=paginav><a class=next href=https://hadjshell.github.io/posts/hello-world/><span class=title>Next »</span><br><span>Hello world!</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share C Notes on twitter" href="https://twitter.com/intent/tweet/?text=C%20Notes&url=https%3a%2f%2fhadjshell.github.io%2fposts%2fc-notes%2f&hashtags=%e5%88%80%e6%b3%95%2cC"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C Notes on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fhadjshell.github.io%2fposts%2fc-notes%2f&title=C%20Notes&summary=C%20Notes&source=https%3a%2f%2fhadjshell.github.io%2fposts%2fc-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C Notes on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhadjshell.github.io%2fposts%2fc-notes%2f&title=C%20Notes"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C Notes on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhadjshell.github.io%2fposts%2fc-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C Notes on whatsapp" href="https://api.whatsapp.com/send?text=C%20Notes%20-%20https%3a%2f%2fhadjshell.github.io%2fposts%2fc-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share C Notes on telegram" href="https://telegram.me/share/url?text=C%20Notes&url=https%3a%2f%2fhadjshell.github.io%2fposts%2fc-notes%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://hadjshell.github.io/>Hadjshell</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>